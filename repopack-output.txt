This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-27T07:27:37.855Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
CMakeLists.txt
CMakeSettings.json
CreateVS2022Solution.bat
include/camera.h
include/display.h
include/drawing.h
include/engine.h
include/input.h
include/lights.h
include/model.h
include/renderer.h
include/scene.h
include/shader.h
include/texture.h
include/tiny_obj_loader.h
LICENSE
README.md
src/camera.cpp
src/display.cpp
src/drawing.cpp
src/engine.cpp
src/input.cpp
src/main.cpp
src/model.cpp
src/renderer.cpp
src/scene.cpp
src/texture.cpp

================================================================
Repository Files
================================================================

================
File: .gitignore
================
*.ipch
*.vsidx
.vs/
.vscode/
build/
vs2022/

================
File: CMakeLists.txt
================
cmake_minimum_required(VERSION 3.21)
project(Software-Renderer)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(FetchContent)

FetchContent_Declare(
    SDL2
    GIT_REPOSITORY https://github.com/libsdl-org/SDL.git
    GIT_TAG release-2.26.5
)
FetchContent_MakeAvailable(SDL2)


FetchContent_Declare(
    SDL2_image
    GIT_REPOSITORY https://github.com/libsdl-org/SDL_image.git
    GIT_TAG release-2.8.0
)
FetchContent_MakeAvailable(SDL2_image)

FetchContent_Declare(
    glm
    GIT_REPOSITORY https://github.com/g-truc/glm.git
    GIT_TAG 0.9.9.6
)
FetchContent_MakeAvailable(glm)

find_package(OpenMP)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/assets)

set(SOURCE_DIR "src")
set(INCLUDE_DIR "include")

set(IMP_FILES 
    ${SOURCE_DIR}/main.cpp
    ${SOURCE_DIR}/renderer.cpp
    ${SOURCE_DIR}/drawing.cpp
    ${SOURCE_DIR}/texture.cpp
    ${SOURCE_DIR}/model.cpp
    ${SOURCE_DIR}/camera.cpp
    ${SOURCE_DIR}/display.cpp
    ${SOURCE_DIR}/scene.cpp
    ${SOURCE_DIR}/input.cpp
    ${SOURCE_DIR}/engine.cpp
)

set(HEADER_FILES
    ${INCLUDE_DIR}/renderer.h
    ${INCLUDE_DIR}/drawing.h
    ${INCLUDE_DIR}/texture.h
    ${INCLUDE_DIR}/model.h
    ${INCLUDE_DIR}/camera.h
    ${INCLUDE_DIR}/display.h
    ${INCLUDE_DIR}/scene.h
    ${INCLUDE_DIR}/input.h
    ${INCLUDE_DIR}/engine.h
)

add_executable(Software-Renderer ${IMP_FILES} ${HEADER_FILES})

target_include_directories(Software-Renderer PUBLIC ${glm_SOURCE_DIR} ${INCLUDE_DIR})

target_link_libraries(Software-Renderer 
    PUBLIC
        SDL2::SDL2main 
        SDL2::SDL2 
        SDL2_image::SDL2_image
        OpenMP::OpenMP_CXX
)

add_custom_command(
    TARGET Software-Renderer POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
        ${CMAKE_CURRENT_SOURCE_DIR}/assets
        $<TARGET_FILE_DIR:Software-Renderer>/assets
)

add_custom_command(
        TARGET Software-Renderer POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy
        $<TARGET_FILE_DIR:SDL2::SDL2>/SDL2.dll
        $<TARGET_FILE_DIR:Software-Renderer>/SDL2.dll
)

add_custom_command(
        TARGET Software-Renderer POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy
        $<TARGET_FILE_DIR:SDL2_image::SDL2_image>/SDL2_image.dll
        $<TARGET_FILE_DIR:Software-Renderer>/SDL2_image.dll
)

add_custom_target(CopyAssets ALL
    DEPENDS Software-Renderer
)

================
File: CMakeSettings.json
================
{
  "configurations": [
    {
      "name": "x64-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    },
    {
      "name": "x64-Release",
      "generator": "Ninja",
      "configurationType": "RelWithDebInfo",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "variables": []
    }
  ]
}

================
File: CreateVS2022Solution.bat
================
REM Set the path to your source code directory
set sourceDir=./

REM Set the path to the directory where you want to generate the Visual Studio project file
set buildDir=./vs2022

REM Check if buildDir exists, if not, create it
if not exist %buildDir% (
    mkdir %buildDir%
)

REM Run CMake to generate the Visual Studio project file
cmake -S %sourceDir% -B %buildDir% -G "Visual Studio 17 2022"

REM Check if the project file was generated successfully
if exist %buildDir%\Software-Renderer.sln (
    echo Visual Studio project file generated successfully.
) else (
    echo Failed to generate Visual Studio project file.
)

================
File: include/camera.h
================
//Class for camera to view from

#ifndef CAMERA_H
#define CAMERA_H

#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "display.h"
#include <vector>

class Camera
{
public:
	Camera();
	~Camera();

	glm::vec3 position = { 0.0f, 0.0f, 3.0f };
	glm::vec3 up = { 0.0f, 1.0f, 0.0f };
	glm::vec3 front = { 0.f, 0.f, -1.f };
	glm::vec3 target = { 0.f, 0.f, 0.f };
	glm::mat4 getPerspective() { return perspective; }
	glm::mat4 getView() { return view; }
	std::vector<glm::vec4> getPlanes() { return frustumPlanes; }

	void calculateFrustumPlanes();

	void UpdateView(glm::vec3 newPos);
	void MoveForward(float delta);
	void MoveBackward(float delta);
	void StrafeLeft(float delta);
	void StrafeRight(float delta);

	void RotateCamera(float deltaYaw, float deltaPitch);

private:

	glm::mat4x4 perspective;
	glm::mat4x4 view;
	float fov;
	float nearPlane;
	float farPlane;

	std::vector<glm::vec4> frustumPlanes;

	float yaw = -90.0f;
	float pitch = 0.0f;


};

#endif

================
File: include/display.h
================
//Display class, it holds the resolution variables, the SDL window
//and is responsible for swapping the buffers

#ifndef DISPLAY_H
#define DISPLAY_H

#include "SDL.h"

class Display
{
public:
	constexpr static int SCREENWIDTH = 1920;
	constexpr static int SCREENHEIGHT = 1080;


	Display();
	~Display();
	bool StartUp();
	bool ShutDown();

	void SwapBuffers(Uint32* pixels);

private:
	
	SDL_Window* mWindow;
	SDL_Surface* mSurface;
};

#endif

================
File: include/drawing.h
================
// This holds all the drawing functions
// All static so that the renderer can freely access
// them in it's own class.

#ifndef DRAWING_H
#define DRAWING_H

#include "renderer.h"
#include "glm/glm.hpp"
#include "shader.h"

class Drawing
{
public:
	Drawing();
	~Drawing();

	static void PutPixel(Uint32* pixels, int x, int y, Uint32 colour);

	static void DrawTriangle(Uint32* pixels, glm::vec4* vertices, PBRShader& shader, float* zBuffer);

	static void ViewPortTransform(glm::vec3* vertices);

	static int gammaAdjust(float n);

	//Pixel format to set final colour to
	static const SDL_PixelFormat* const pixelFormat;

private:
	
};

#endif

================
File: include/engine.h
================
// Engine class, responsible for setting up everything in
// the renderer and has the main event loop

#ifndef ENGINE_H
#define ENGINE_H
#include "renderer.h"
#include "display.h"
#include "input.h"
class Engine
{
public:
	Engine();
	~Engine();

	bool StartUp();

	void ShutDown();

	void Run();

private:

	Display displayInstance;
	Input inputInstance;
	Renderer renderInstance;

	
};

#endif

================
File: include/input.h
================
// Class for processing the user input for the renderer

#ifndef INPUT_H
#define INPUT_H
#include "renderer.h"

class Input
{
public:
	Input();
	~Input();

	bool StartUp(Renderer* renderer);

	void ProcessEvents(bool& quit, Uint32 totalFrameTime);

	void ShutDown();

private:
	Renderer* mRenderer;

	float lastMouseX = 0;
	float lastMouseY = 0;
};

#endif

================
File: include/lights.h
================
#ifndef LIGHTS_H
#define LIGHTS_H
#include <string>
#include "SDL.h"
#include "glm/glm.hpp"
#include <iostream>

struct Lights
{
	Lights(glm::vec3 position, float intensity, glm::vec3 color) : position(position), intensity(intensity), color(color) {};

	~Lights() = default;

    void Update(float delta)
    {
        totalTime += delta; // Update totalTime with the passed delta
        float ang = totalTime * time;

        float radius = 4.0f; // Set the desired radius of the circle around the model
        glm::vec3 modelCenter = glm::vec3(0.0f, 0.0f, 0.0f); // Set the center of the model

        // Update position.x and position.z using the calculated angle and radius
        position.x = modelCenter.x + radius * sin(ang);
        //position.y = modelCenter.y + radius * sin(ang);
        position.z = modelCenter.z + radius * cos(ang);
    }



	glm::vec3 position;
	float intensity;
	glm::vec3 color;
	float time = 0.0005f;
	Uint32 totalTime = 0;
};

#endif

================
File: include/model.h
================
//Class for loading the mesh data and the functions for retrieving that
//data. Also has all the textures associated with the model.


#ifndef MODEL_H
#define MODEL_H

#include "texture.h"
#include "glm/glm.hpp"
#include "glm/gtc/quaternion.hpp"
#include "glm/gtx/quaternion.hpp"
#include <vector>
#include <string>


struct AABB
{
	glm::vec3 min;
	glm::vec3 max;
};


//I previously held all the data in a vector of triangle structs which contained 3 of each of the vertices
//However, I found this to have enough of an impact on performance and it complicated things too much
//so I separated everything out into their own vectors and it increased performance by roughly 1.5x.
class Model
{
public:
	Model();
	~Model();

	bool loadModel(const std::string& filename);

	std::vector<glm::vec3>* getVertices() { return &mVertices; }
	std::vector<glm::vec3>* getNormals() { return &mNormals; }
	std::vector<glm::vec3>* getUV() { return &mUVs; }
	std::vector<glm::vec3>* getTangent() { return &mTangents; }
	std::vector<glm::vec3>* getFaceNormals() { return &mFaceNormals; }

	std::vector<glm::ivec3>* getVertexIndices() { return &mVertexIndices; }
	std::vector<glm::ivec3>* getTextureIndices() { return &mTextureIndices; }
	std::vector<glm::ivec3>* getNormalIndices() { return &mNormalIndices; }


	void CalculateTangent();

	void SetTranslate(glm::vec3 translate);
	void SetRotation(glm::vec3 rotation);
	void SetScale(glm::vec3 scale);
	void SetModelMatrix();

	glm::mat4 GetModelMatrix();

	AABB mBoundingBox;

	Texture mAlbedo;
	Texture mNormal;
	Texture mMetallic;
	Texture mRoughness;
	Texture mAmbientO;
	Texture mHeight;

	int mNumFaces = 0;

	glm::vec3 rotate;

private:
	
	Uint32 totalTime;

	std::vector<glm::vec3> mVertices;
	std::vector<glm::vec3> mNormals;
	std::vector<glm::vec3> mUVs;
	std::vector<glm::vec3> mTangents;
	std::vector<glm::vec3> mBiTangents;

	
	std::vector<glm::vec3> mFaceNormals;
	std::vector<glm::ivec3> mVertexIndices;
	std::vector<glm::ivec3> mTextureIndices;
	std::vector<glm::ivec3> mNormalIndices;


	glm::mat4 mModelMatrix = glm::mat4(1.0f);
	glm::mat4 mTranslate;
	glm::mat4 mRotation;
	glm::mat4 mScale;
};
#endif

================
File: include/renderer.h
================
//Renderer class, holds most of the rendering logic

#ifndef RENDERER_H
#define RENDERER_H

#include "display.h"
#include "drawing.h"
#include "shader.h"
#include "scene.h"

class Renderer
{
public:
	Renderer();
	~Renderer();

	bool StartUp(const int w, const int h);
	bool ShutDown();


	//Main rendering loop
	//First sets up the shader variables from the models in the scene
	//Second determines whether the face can be seen by the camera, if not culls the triangle
	//Third transforms the vertices to world and camera space
	//Fourth clips triangles that are not on screen
	//Fifth sends the vertices off to get renderered in the drawing class
	void render();

	//Packs the vertices into triangles for the renderer
	void createTriangles(glm::ivec3& index, glm::vec3* primitive, std::vector<glm::vec3>& vals);

	Uint32* getPixelBuffer();
	Camera* getSceneCamera() { return &mCurrentScene.getCamera(); }
	Scene& getScene() { return mCurrentScene; }

	//Clips triangles but doesn't rebuild them
	//Hard to rebuild triangles in the data structure I have set up
	//If I had a vector of triangles, it would be easier to create
	//triangles to draw.
	//Separating out the data into their own vectors creates a massive speed up however
	//Worth profiling between the two solutions
	//This clipping routine also comes from Angel Ortiz's software renderer
	bool clipTriangles(glm::vec4* clipSpaceVerts);

	//Clears pixel buffer and z-buffer
	void bufferClear();

	void loadScene(std::string& filePath);



	bool BackfaceCulling(glm::vec3& faceNorm, glm::vec3& vert, glm::mat4& worldToObject);

	void setCurrentScene(std::string& filePath);
	void clearScene();


private:

	Uint32* mPixelBuffer;
	float* mZbuffer;

	Scene mCurrentScene;

	
};

#endif

================
File: include/scene.h
================
//Class for loading the complete scene into the program

#ifndef SCENE_H
#define SCENE_H

#include "model.h"
#include "camera.h"
#include <memory>
#include <string>
#include "lights.h"

class Scene
{
public:
    Scene();
    ~Scene();

    void loadScene(std::string& sceneFile);

    Camera& getCamera() { return mCamera; }

    std::vector<Model*> getScene();
    std::vector<Lights*> getLights();

    void UpdateLights(int delta);
    void clearScene();

private:

    //Use smart pointers because I wanted to learn more about them
    //If I had a chance to redo, I think I would manage my own memory
    //As I think there is a bit of overhead involved.
    std::vector<std::unique_ptr<Model>> modelsInScene;
    std::vector<std::unique_ptr<Lights>> lightsInScene;

    int numModels = 0;
    int mNumLights = 0;

    std::string name;

    Camera mCamera;

};



#endif

================
File: include/shader.h
================
//This is where the pixel shading happens.
//Only has a PBR shader as I thought the other ones were cluttering
//up the header file. Means I could've done this without inheritance.

#ifndef SHADER_H
#define SHADER_H

#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "renderer.h"
#include "model.h"
#include "camera.h"
#include "lights.h"
#include <iostream>

#define PI 3.14159265359f

struct IShader
{
	virtual glm::vec4 vertex(glm::vec3 position, glm::vec3& uv, glm::vec3& tangent, glm::vec3& normal, int index) = 0;
	virtual glm::vec3 fragment(glm::vec3 bar) = 0;
};

struct PBRShader : IShader
{
    //Camera position
    glm::vec3 cameraPos;

    //Textures
    Texture* mAlbedo;
    Texture* mNormal;
    Texture* mAO;
    Texture* mMetal;
    Texture* mRough;
    Texture* mHeight;

    //Height scaling factor
    float heightScale = 0.05f;

    //Model data
    glm::vec3 varyingUV[3];
    glm::vec3 varyingNorm[3];
    glm::vec3 Tan[3];
    glm::vec3 BiTan[3];
    glm::vec3 Normal[3];
    glm::vec3 varyingWorld[3];
   
    //Matrices
    glm::mat4 MV, MVP, M, V, N;
    glm::mat3 TBN;

    //Light variables
    std::vector<Lights*> lights;
    glm::vec3 lightPosition;
    glm::vec3 lightDir[3];
    float intensity;
    glm::vec3 lightColor;

    float DistributionGGX(glm::vec3 N, glm::vec3 H, float roughness)
    {
        float a = roughness * roughness;
        float a2 = a * a;
        float NdotH = std::max(dot(N, H), 0.0f);
        float NdotH2 = NdotH * NdotH;

        float nom = a2;
        float denom = (NdotH2 * (a2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    float GeometrySchlickGGX(float NdotV, float roughness)
    {
        float r = (roughness + 1.0f);
        float k = (r * r) / 8.0f;

        float nom = NdotV;
        float denom = NdotV * (1.0f - k) + k;

        return nom / denom;
    }

    float GeometrySmith(glm::vec3 N, glm::vec3 V, glm::vec3 L, float roughness)
    {
        float NdotV = std::max(dot(N, V), 0.0f);
        float NdotL = std::max(dot(N, L), 0.0f);
        float ggx2 = GeometrySchlickGGX(NdotV, roughness);
        float ggx1 = GeometrySchlickGGX(NdotL, roughness);

        return ggx1 * ggx2;
    }

    glm::vec3 fresnelSchlick(float cosTheta, glm::vec3 F0)
    {
        float invcCosTheta = 1.0 - cosTheta;
        return F0 + (glm::vec3(1.0) - F0) * (invcCosTheta * invcCosTheta * invcCosTheta * invcCosTheta * invcCosTheta);      
    }

    float FresnelDiffuse(glm::vec3 N, glm::vec3 L, glm::vec3 V, glm::vec3 F0)
    {
        float NdotL = std::max(glm::dot(N, L), 0.0f);
        float NdotV = std::max(glm::dot(N, V), 0.0f);

        float invNdotLPow5 = pow(1.0f - NdotL, 5.0f);
        float invNdotVPow5 = pow(1.0f - NdotV, 5.0f);

        float Fd = (1.0f - F0.x) * 21.0f / (20.0f * PI) * (1.0f - invNdotLPow5) * (1.0f - invNdotVPow5);

        return Fd;
    }

    //Parallax occlusion mapping
    glm::vec2 parallaxUV(glm::vec2 uv, glm::vec3 viewDir)
    {
        int numLayers = 128;

        float layerDepth = 1.0 / numLayers;
        float curLayerDepth = 0.0;
        glm::vec2 deltaUV = glm::vec2(viewDir.x, viewDir.y) * heightScale / (viewDir.z * numLayers);
        glm::vec2 curUV = uv;

        float depthFromTex = mHeight->SampleTexture(curUV.x, curUV.y).r;

        // Find depth value
        for (int i = 0; i < numLayers; i++) 
        {
            curLayerDepth += layerDepth;
            curUV -= deltaUV;
            depthFromTex = mHeight->SampleTexture(curUV.x, curUV.y).r;
            if (depthFromTex < curLayerDepth)
            {
                break;
            }
        }

        // Interpolate UV's
        glm::vec2 prevUV = curUV + deltaUV;
        float next = depthFromTex - curLayerDepth;
        float prev = mHeight->SampleTexture(prevUV.x, prevUV.y).r - curLayerDepth + layerDepth;
        float weight = next / (next - prev);
        return glm::mix(curUV, prevUV, weight);
    }
  
    virtual glm::vec4 vertex(glm::vec3 position, glm::vec3& uv, glm::vec3& tangent, glm::vec3& normal, int index) override
    {
        // Setup TBN variables
        Normal[index] = (M * glm::vec4(normal, 0.0f));
        Tan[index] = (M * glm::vec4(tangent, 0.0f));
        BiTan[index] = (glm::cross(Normal[index], Tan[index]));
        
        glm::vec4 v = glm::vec4(position, 1.0f);

        varyingWorld[index] = glm::vec3(M * v);

        varyingNorm[index] = N * glm::vec4(normal, 1.0f);

        varyingUV[index] = uv;

        return MVP * v;
    }



    virtual glm::vec3 fragment(glm::vec3 bar) override
    {
        // Interpolate UV's
        float u = (varyingUV[0].x * bar.x) + (varyingUV[1].x * bar.y) + (varyingUV[2].x * bar.z);
        float v = (varyingUV[0].y * bar.x) + (varyingUV[1].y * bar.y) + (varyingUV[2].y * bar.z);

        // Interpolate the tangent, bitangent and normals
        glm::vec3 tangent = glm::normalize((Tan[0] * bar.x) + (Tan[1] * bar.y) + (Tan[2] * bar.z));
        glm::vec3 normal = glm::normalize((Normal[0] * bar.x) + (Normal[1] * bar.y) + (Normal[2] * bar.z));
        glm::vec3 bitangent = glm::normalize((BiTan[0] * bar.x) + (BiTan[1] * bar.y) + (BiTan[2] * bar.z));

        // build TBN matrix
        TBN = (glm::mat3(tangent, bitangent, normal));

        // Interpolate fragment position
        glm::vec3 fragPos = glm::vec3(varyingWorld[0] * bar.x + varyingWorld[1] * bar.y + varyingWorld[2] * bar.z);

        //fragPos = TBN * fragPos;


        glm::vec3 viewDir = glm::normalize(cameraPos - fragPos);

        //viewDir = TBN * viewDir;

        glm::vec2 heightUV = parallaxUV(glm::vec2(u, v), viewDir);
        //glm::vec2 heightUV = glm::vec2(u, v);

        // Sample the albedo and normal textures
        // Accessing the textures is a large use of CPU time
        // Could write the sample texture function so that it
        // is more cache friendly.
        glm::vec3 albedo = mAlbedo->SampleTexture(heightUV.x,heightUV.y);
        glm::vec3 tNormal = mNormal->SampleTexture(heightUV.x, heightUV.y);
        float ao = mAO->SampleTexture(heightUV.x, heightUV.y).r;
        float metalness = mMetal->SampleTexture(heightUV.x, heightUV.y).r;
        float roughness = mRough->SampleTexture(heightUV.x, heightUV.y).r;
        float height = mHeight->SampleTexture(heightUV.x, heightUV.y).r;
        //Correct normal values
        tNormal = glm::normalize(tNormal * 2.0f - 1.0f);
        tNormal = glm::normalize(TBN * tNormal);

        // Corrects the F0 between metal and Dielectric
        // derived from Angel Ortiz's software renderer
        glm::vec3 F0 = glm::vec3(0.04f);
        
        F0 = glm::mix(F0, albedo, metalness);
        float invMetal = (1.0f - metalness);
        glm::vec3 F0Correct = (F0 * invMetal) + (albedo * metalness);
        glm::vec3 Lo = glm::vec3(0.0f);

        float constant = 1.0f;
        float linear = 0.09f;
        float quadratic = 0.032f;

        // Apply PBR shading for each light in the lights vector
        // PBR shader derived from LearnOpenGL
        for (int i = 0; i < lights.size(); i++)
        {

            //Retrieve data from the lights vector
            lightPosition = lights[i]->position;
            intensity = lights[i]->intensity;
            lightColor = lights[i]->color;

            //Light direction
            glm::vec3 L = glm::normalize(lightPosition - fragPos);
            //Calculating half-vector
            glm::vec3 H = glm::normalize(viewDir + L);

            //Calculate dot product between normal and light direction
            float NdotL = std::max(glm::dot(tNormal, L), 0.0f);

            //Calculating the attenuation for the point lights in the scene
            float distance = glm::length(lightPosition - fragPos);
            float attenuation = 1.0f / (constant + linear * distance + quadratic * (distance * distance));
            glm::vec3 radiance = lightColor * attenuation;

            //BRDF Cook-Torrance
            float NDF = DistributionGGX(tNormal, H, roughness);
            float G = GeometrySmith(tNormal, viewDir, H, roughness);
            glm::vec3 F = fresnelSchlick(std::max(glm::dot(H, L), 0.0f), F0Correct);
            float Fd = FresnelDiffuse(tNormal, L, H, F0);
   
            glm::vec3 numerator = NDF * G * F;
            float denominator = 4.0f * std::max(glm::dot(tNormal, viewDir), 0.0f) * std::max(glm::dot(tNormal, L), 0.0f) + 0.0001f;
            glm::vec3 specular = (numerator / denominator);

            glm::vec3 kS = F;
            glm::vec3 kD = (glm::vec3(1.0f) - kS);

            kD *= invMetal;

            Lo += ((kD * (albedo / PI) * Fd) + specular) * NdotL * radiance * intensity;
        }

        //Simple ambient term
        glm::vec3 ambient = glm::vec3(0.2f) * albedo;

        Lo *= ao;

        glm::vec3 color = Lo + ambient;

        glm::vec3 linearColor = glm::pow(color, glm::vec3(2.2f, 2.2f, 2.2f));

        //Correct HDR colours
        linearColor = linearColor / (linearColor + glm::vec3(1.0f));
         
        return linearColor;
    }
};
#endif

================
File: include/texture.h
================
#ifndef TEXTURE_H
#define TEXTURE_H
#include "SDL.h"
#include "SDL_image.h"
#include <string>
#include "glm/glm.hpp"


class Texture
{
public:
	Texture();
	~Texture();

	void LoadTexture(const std::string& filename);
	void TileData();

	Uint32 GetPixel(int u, int v) const;
	glm::vec3 SampleTexture(float u, float v) const;

private:
	SDL_Surface* mTextureSurface;
	int width;
	int height;

	int tileW = 32;
	int tileH = 32;
};
#endif

================
File: include/tiny_obj_loader.h
================
/*
The MIT License (MIT)

Copyright (c) 2012-Present, Syoyo Fujita and many contributors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

//
// version 2.0.0 : Add new object oriented API. 1.x API is still provided.
//                 * Support line primitive.
//                 * Support points primitive.
//                 * Support multiple search path for .mtl(v1 API).
//                 * Support vertex weight `vw`(as an tinyobj extension)
//                 * Support escaped whitespece in mtllib
//                 * Add robust triangulation using Mapbox earcut(TINYOBJLOADER_USE_MAPBOX_EARCUT).
// version 1.4.0 : Modifed ParseTextureNameAndOption API
// version 1.3.1 : Make ParseTextureNameAndOption API public
// version 1.3.0 : Separate warning and error message(breaking API of LoadObj)
// version 1.2.3 : Added color space extension('-colorspace') to tex opts.
// version 1.2.2 : Parse multiple group names.
// version 1.2.1 : Added initial support for line('l') primitive(PR #178)
// version 1.2.0 : Hardened implementation(#175)
// version 1.1.1 : Support smoothing groups(#162)
// version 1.1.0 : Support parsing vertex color(#144)
// version 1.0.8 : Fix parsing `g` tag just after `usemtl`(#138)
// version 1.0.7 : Support multiple tex options(#126)
// version 1.0.6 : Add TINYOBJLOADER_USE_DOUBLE option(#124)
// version 1.0.5 : Ignore `Tr` when `d` exists in MTL(#43)
// version 1.0.4 : Support multiple filenames for 'mtllib'(#112)
// version 1.0.3 : Support parsing texture options(#85)
// version 1.0.2 : Improve parsing speed by about a factor of 2 for large
// files(#105)
// version 1.0.1 : Fixes a shape is lost if obj ends with a 'usemtl'(#104)
// version 1.0.0 : Change data structure. Change license from BSD to MIT.
//

//
// Use this in *one* .cc
//   #define TINYOBJLOADER_IMPLEMENTATION
//   #include "tiny_obj_loader.h"
//

#ifndef TINY_OBJ_LOADER_H_
#define TINY_OBJ_LOADER_H_

#include <map>
#include <string>
#include <vector>

namespace tinyobj {

// TODO(syoyo): Better C++11 detection for older compiler
#if __cplusplus > 199711L
#define TINYOBJ_OVERRIDE override
#else
#define TINYOBJ_OVERRIDE
#endif

#ifdef __clang__
#pragma clang diagnostic push
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif

#pragma clang diagnostic ignored "-Wpadded"

#endif

// https://en.wikipedia.org/wiki/Wavefront_.obj_file says ...
//
//  -blendu on | off                       # set horizontal texture blending
//  (default on)
//  -blendv on | off                       # set vertical texture blending
//  (default on)
//  -boost real_value                      # boost mip-map sharpness
//  -mm base_value gain_value              # modify texture map values (default
//  0 1)
//                                         #     base_value = brightness,
//                                         gain_value = contrast
//  -o u [v [w]]                           # Origin offset             (default
//  0 0 0)
//  -s u [v [w]]                           # Scale                     (default
//  1 1 1)
//  -t u [v [w]]                           # Turbulence                (default
//  0 0 0)
//  -texres resolution                     # texture resolution to create
//  -clamp on | off                        # only render texels in the clamped
//  0-1 range (default off)
//                                         #   When unclamped, textures are
//                                         repeated across a surface,
//                                         #   when clamped, only texels which
//                                         fall within the 0-1
//                                         #   range are rendered.
//  -bm mult_value                         # bump multiplier (for bump maps
//  only)
//
//  -imfchan r | g | b | m | l | z         # specifies which channel of the file
//  is used to
//                                         # create a scalar or bump texture.
//                                         r:red, g:green,
//                                         # b:blue, m:matte, l:luminance,
//                                         z:z-depth..
//                                         # (the default for bump is 'l' and
//                                         for decal is 'm')
//  bump -imfchan r bumpmap.tga            # says to use the red channel of
//  bumpmap.tga as the bumpmap
//
// For reflection maps...
//
//   -type sphere                           # specifies a sphere for a "refl"
//   reflection map
//   -type cube_top    | cube_bottom |      # when using a cube map, the texture
//   file for each
//         cube_front  | cube_back   |      # side of the cube is specified
//         separately
//         cube_left   | cube_right
//
// TinyObjLoader extension.
//
//   -colorspace SPACE                      # Color space of the texture. e.g.
//   'sRGB` or 'linear'
//

#ifdef TINYOBJLOADER_USE_DOUBLE
//#pragma message "using double"
typedef double real_t;
#else
//#pragma message "using float"
typedef float real_t;
#endif

typedef enum {
  TEXTURE_TYPE_NONE,  // default
  TEXTURE_TYPE_SPHERE,
  TEXTURE_TYPE_CUBE_TOP,
  TEXTURE_TYPE_CUBE_BOTTOM,
  TEXTURE_TYPE_CUBE_FRONT,
  TEXTURE_TYPE_CUBE_BACK,
  TEXTURE_TYPE_CUBE_LEFT,
  TEXTURE_TYPE_CUBE_RIGHT
} texture_type_t;

struct texture_option_t {
  texture_type_t type;      // -type (default TEXTURE_TYPE_NONE)
  real_t sharpness;         // -boost (default 1.0?)
  real_t brightness;        // base_value in -mm option (default 0)
  real_t contrast;          // gain_value in -mm option (default 1)
  real_t origin_offset[3];  // -o u [v [w]] (default 0 0 0)
  real_t scale[3];          // -s u [v [w]] (default 1 1 1)
  real_t turbulence[3];     // -t u [v [w]] (default 0 0 0)
  int texture_resolution;   // -texres resolution (No default value in the spec.
                            // We'll use -1)
  bool clamp;               // -clamp (default false)
  char imfchan;  // -imfchan (the default for bump is 'l' and for decal is 'm')
  bool blendu;   // -blendu (default on)
  bool blendv;   // -blendv (default on)
  real_t bump_multiplier;  // -bm (for bump maps only, default 1.0)

  // extension
  std::string colorspace;  // Explicitly specify color space of stored texel
                           // value. Usually `sRGB` or `linear` (default empty).
};

struct material_t {
  std::string name;

  real_t ambient[3];
  real_t diffuse[3];
  real_t specular[3];
  real_t transmittance[3];
  real_t emission[3];
  real_t shininess;
  real_t ior;       // index of refraction
  real_t dissolve;  // 1 == opaque; 0 == fully transparent
  // illumination model (see http://www.fileformat.info/format/material/)
  int illum;

  int dummy;  // Suppress padding warning.

  std::string ambient_texname;             // map_Ka. For ambient or ambient occlusion.
  std::string diffuse_texname;             // map_Kd
  std::string specular_texname;            // map_Ks
  std::string specular_highlight_texname;  // map_Ns
  std::string bump_texname;                // map_bump, map_Bump, bump
  std::string displacement_texname;        // disp
  std::string alpha_texname;               // map_d
  std::string reflection_texname;          // refl

  texture_option_t ambient_texopt;
  texture_option_t diffuse_texopt;
  texture_option_t specular_texopt;
  texture_option_t specular_highlight_texopt;
  texture_option_t bump_texopt;
  texture_option_t displacement_texopt;
  texture_option_t alpha_texopt;
  texture_option_t reflection_texopt;

  // PBR extension
  // http://exocortex.com/blog/extending_wavefront_mtl_to_support_pbr
  real_t roughness;            // [0, 1] default 0
  real_t metallic;             // [0, 1] default 0
  real_t sheen;                // [0, 1] default 0
  real_t clearcoat_thickness;  // [0, 1] default 0
  real_t clearcoat_roughness;  // [0, 1] default 0
  real_t anisotropy;           // aniso. [0, 1] default 0
  real_t anisotropy_rotation;  // anisor. [0, 1] default 0
  real_t pad0;
  std::string roughness_texname;  // map_Pr
  std::string metallic_texname;   // map_Pm
  std::string sheen_texname;      // map_Ps
  std::string emissive_texname;   // map_Ke
  std::string normal_texname;     // norm. For normal mapping.

  texture_option_t roughness_texopt;
  texture_option_t metallic_texopt;
  texture_option_t sheen_texopt;
  texture_option_t emissive_texopt;
  texture_option_t normal_texopt;

  int pad2;

  std::map<std::string, std::string> unknown_parameter;

#ifdef TINY_OBJ_LOADER_PYTHON_BINDING
  // For pybind11
  std::array<double, 3> GetDiffuse() {
    std::array<double, 3> values;
    values[0] = double(diffuse[0]);
    values[1] = double(diffuse[1]);
    values[2] = double(diffuse[2]);

    return values;
  }

  std::array<double, 3> GetSpecular() {
    std::array<double, 3> values;
    values[0] = double(specular[0]);
    values[1] = double(specular[1]);
    values[2] = double(specular[2]);

    return values;
  }

  std::array<double, 3> GetTransmittance() {
    std::array<double, 3> values;
    values[0] = double(transmittance[0]);
    values[1] = double(transmittance[1]);
    values[2] = double(transmittance[2]);

    return values;
  }

  std::array<double, 3> GetEmission() {
    std::array<double, 3> values;
    values[0] = double(emission[0]);
    values[1] = double(emission[1]);
    values[2] = double(emission[2]);

    return values;
  }

  std::array<double, 3> GetAmbient() {
    std::array<double, 3> values;
    values[0] = double(ambient[0]);
    values[1] = double(ambient[1]);
    values[2] = double(ambient[2]);

    return values;
  }

  void SetDiffuse(std::array<double, 3> &a) {
    diffuse[0] = real_t(a[0]);
    diffuse[1] = real_t(a[1]);
    diffuse[2] = real_t(a[2]);
  }

  void SetAmbient(std::array<double, 3> &a) {
    ambient[0] = real_t(a[0]);
    ambient[1] = real_t(a[1]);
    ambient[2] = real_t(a[2]);
  }

  void SetSpecular(std::array<double, 3> &a) {
    specular[0] = real_t(a[0]);
    specular[1] = real_t(a[1]);
    specular[2] = real_t(a[2]);
  }

  void SetTransmittance(std::array<double, 3> &a) {
    transmittance[0] = real_t(a[0]);
    transmittance[1] = real_t(a[1]);
    transmittance[2] = real_t(a[2]);
  }

  std::string GetCustomParameter(const std::string &key) {
    std::map<std::string, std::string>::const_iterator it =
        unknown_parameter.find(key);

    if (it != unknown_parameter.end()) {
      return it->second;
    }
    return std::string();
  }

#endif
};

struct tag_t {
  std::string name;

  std::vector<int> intValues;
  std::vector<real_t> floatValues;
  std::vector<std::string> stringValues;
};

struct joint_and_weight_t {
  int joint_id;
  real_t weight;
};

struct skin_weight_t {
  int vertex_id;  // Corresponding vertex index in `attrib_t::vertices`.
                  // Compared to `index_t`, this index must be positive and
                  // start with 0(does not allow relative indexing)
  std::vector<joint_and_weight_t> weightValues;
};

// Index struct to support different indices for vtx/normal/texcoord.
// -1 means not used.
struct index_t {
  int vertex_index;
  int normal_index;
  int texcoord_index;
};

struct mesh_t {
  std::vector<index_t> indices;
  std::vector<unsigned char>
      num_face_vertices;          // The number of vertices per
                                  // face. 3 = triangle, 4 = quad,
                                  // ... Up to 255 vertices per face.
  std::vector<int> material_ids;  // per-face material ID
  std::vector<unsigned int> smoothing_group_ids;  // per-face smoothing group
                                                  // ID(0 = off. positive value
                                                  // = group id)
  std::vector<tag_t> tags;                        // SubD tag
};

// struct path_t {
//  std::vector<int> indices;  // pairs of indices for lines
//};

struct lines_t {
  // Linear flattened indices.
  std::vector<index_t> indices;        // indices for vertices(poly lines)
  std::vector<int> num_line_vertices;  // The number of vertices per line.
};

struct points_t {
  std::vector<index_t> indices;  // indices for points
};

struct shape_t {
  std::string name;
  mesh_t mesh;
  lines_t lines;
  points_t points;
};

// Vertex attributes
struct attrib_t {
  std::vector<real_t> vertices;  // 'v'(xyz)

  // For backward compatibility, we store vertex weight in separate array.
  std::vector<real_t> vertex_weights;  // 'v'(w)
  std::vector<real_t> normals;         // 'vn'
  std::vector<real_t> texcoords;       // 'vt'(uv)

  // For backward compatibility, we store texture coordinate 'w' in separate
  // array.
  std::vector<real_t> texcoord_ws;  // 'vt'(w)
  std::vector<real_t> colors;       // extension: vertex colors

  //
  // TinyObj extension.
  //

  // NOTE(syoyo): array index is based on the appearance order.
  // To get a corresponding skin weight for a specific vertex id `vid`,
  // Need to reconstruct a look up table: `skin_weight_t::vertex_id` == `vid`
  // (e.g. using std::map, std::unordered_map)
  std::vector<skin_weight_t> skin_weights;

  attrib_t() {}

  //
  // For pybind11
  //
  const std::vector<real_t> &GetVertices() const { return vertices; }

  const std::vector<real_t> &GetVertexWeights() const { return vertex_weights; }
};

struct callback_t {
  // W is optional and set to 1 if there is no `w` item in `v` line
  void (*vertex_cb)(void *user_data, real_t x, real_t y, real_t z, real_t w);
  void (*vertex_color_cb)(void *user_data, real_t x, real_t y, real_t z,
                          real_t r, real_t g, real_t b, bool has_color);
  void (*normal_cb)(void *user_data, real_t x, real_t y, real_t z);

  // y and z are optional and set to 0 if there is no `y` and/or `z` item(s) in
  // `vt` line.
  void (*texcoord_cb)(void *user_data, real_t x, real_t y, real_t z);

  // called per 'f' line. num_indices is the number of face indices(e.g. 3 for
  // triangle, 4 for quad)
  // 0 will be passed for undefined index in index_t members.
  void (*index_cb)(void *user_data, index_t *indices, int num_indices);
  // `name` material name, `material_id` = the array index of material_t[]. -1
  // if
  // a material not found in .mtl
  void (*usemtl_cb)(void *user_data, const char *name, int material_id);
  // `materials` = parsed material data.
  void (*mtllib_cb)(void *user_data, const material_t *materials,
                    int num_materials);
  // There may be multiple group names
  void (*group_cb)(void *user_data, const char **names, int num_names);
  void (*object_cb)(void *user_data, const char *name);

  callback_t()
      : vertex_cb(NULL),
        vertex_color_cb(NULL),
        normal_cb(NULL),
        texcoord_cb(NULL),
        index_cb(NULL),
        usemtl_cb(NULL),
        mtllib_cb(NULL),
        group_cb(NULL),
        object_cb(NULL) {}
};

class MaterialReader {
 public:
  MaterialReader() {}
  virtual ~MaterialReader();

  virtual bool operator()(const std::string &matId,
                          std::vector<material_t> *materials,
                          std::map<std::string, int> *matMap, std::string *warn,
                          std::string *err) = 0;
};

///
/// Read .mtl from a file.
///
class MaterialFileReader : public MaterialReader {
 public:
  // Path could contain separator(';' in Windows, ':' in Posix)
  explicit MaterialFileReader(const std::string &mtl_basedir)
      : m_mtlBaseDir(mtl_basedir) {}
  virtual ~MaterialFileReader() TINYOBJ_OVERRIDE {}
  virtual bool operator()(const std::string &matId,
                          std::vector<material_t> *materials,
                          std::map<std::string, int> *matMap, std::string *warn,
                          std::string *err) TINYOBJ_OVERRIDE;

 private:
  std::string m_mtlBaseDir;
};

///
/// Read .mtl from a stream.
///
class MaterialStreamReader : public MaterialReader {
 public:
  explicit MaterialStreamReader(std::istream &inStream)
      : m_inStream(inStream) {}
  virtual ~MaterialStreamReader() TINYOBJ_OVERRIDE {}
  virtual bool operator()(const std::string &matId,
                          std::vector<material_t> *materials,
                          std::map<std::string, int> *matMap, std::string *warn,
                          std::string *err) TINYOBJ_OVERRIDE;

 private:
  std::istream &m_inStream;
};

// v2 API
struct ObjReaderConfig {
  bool triangulate;  // triangulate polygon?

  // Currently not used.
  // "simple" or empty: Create triangle fan
  // "earcut": Use the algorithm based on Ear clipping
  std::string triangulation_method;

  /// Parse vertex color.
  /// If vertex color is not present, its filled with default value.
  /// false = no vertex color
  /// This will increase memory of parsed .obj
  bool vertex_color;

  ///
  /// Search path to .mtl file.
  /// Default = "" = search from the same directory of .obj file.
  /// Valid only when loading .obj from a file.
  ///
  std::string mtl_search_path;

  ObjReaderConfig()
      : triangulate(true), triangulation_method("simple"), vertex_color(true) {}
};

///
/// Wavefront .obj reader class(v2 API)
///
class ObjReader {
 public:
  ObjReader() : valid_(false) {}

  ///
  /// Load .obj and .mtl from a file.
  ///
  /// @param[in] filename wavefront .obj filename
  /// @param[in] config Reader configuration
  ///
  bool ParseFromFile(const std::string &filename,
                     const ObjReaderConfig &config = ObjReaderConfig());

  ///
  /// Parse .obj from a text string.
  /// Need to supply .mtl text string by `mtl_text`.
  /// This function ignores `mtllib` line in .obj text.
  ///
  /// @param[in] obj_text wavefront .obj filename
  /// @param[in] mtl_text wavefront .mtl filename
  /// @param[in] config Reader configuration
  ///
  bool ParseFromString(const std::string &obj_text, const std::string &mtl_text,
                       const ObjReaderConfig &config = ObjReaderConfig());

  ///
  /// .obj was loaded or parsed correctly.
  ///
  bool Valid() const { return valid_; }

  const attrib_t &GetAttrib() const { return attrib_; }

  const std::vector<shape_t> &GetShapes() const { return shapes_; }

  const std::vector<material_t> &GetMaterials() const { return materials_; }

  ///
  /// Warning message(may be filled after `Load` or `Parse`)
  ///
  const std::string &Warning() const { return warning_; }

  ///
  /// Error message(filled when `Load` or `Parse` failed)
  ///
  const std::string &Error() const { return error_; }

 private:
  bool valid_;

  attrib_t attrib_;
  std::vector<shape_t> shapes_;
  std::vector<material_t> materials_;

  std::string warning_;
  std::string error_;
};

/// ==>>========= Legacy v1 API =============================================

/// Loads .obj from a file.
/// 'attrib', 'shapes' and 'materials' will be filled with parsed shape data
/// 'shapes' will be filled with parsed shape data
/// Returns true when loading .obj become success.
/// Returns warning message into `warn`, and error message into `err`
/// 'mtl_basedir' is optional, and used for base directory for .mtl file.
/// In default(`NULL'), .mtl file is searched from an application's working
/// directory.
/// 'triangulate' is optional, and used whether triangulate polygon face in .obj
/// or not.
/// Option 'default_vcols_fallback' specifies whether vertex colors should
/// always be defined, even if no colors are given (fallback to white).
bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, const char *filename,
             const char *mtl_basedir = NULL, bool triangulate = true,
             bool default_vcols_fallback = true);

/// Loads .obj from a file with custom user callback.
/// .mtl is loaded as usual and parsed material_t data will be passed to
/// `callback.mtllib_cb`.
/// Returns true when loading .obj/.mtl become success.
/// Returns warning message into `warn`, and error message into `err`
/// See `examples/callback_api/` for how to use this function.
bool LoadObjWithCallback(std::istream &inStream, const callback_t &callback,
                         void *user_data = NULL,
                         MaterialReader *readMatFn = NULL,
                         std::string *warn = NULL, std::string *err = NULL);

/// Loads object from a std::istream, uses `readMatFn` to retrieve
/// std::istream for materials.
/// Returns true when loading .obj become success.
/// Returns warning and error message into `err`
bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, std::istream *inStream,
             MaterialReader *readMatFn = NULL, bool triangulate = true,
             bool default_vcols_fallback = true);

/// Loads materials into std::map
void LoadMtl(std::map<std::string, int> *material_map,
             std::vector<material_t> *materials, std::istream *inStream,
             std::string *warning, std::string *err);

///
/// Parse texture name and texture option for custom texture parameter through
/// material::unknown_parameter
///
/// @param[out] texname Parsed texture name
/// @param[out] texopt Parsed texopt
/// @param[in] linebuf Input string
///
bool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,
                               const char *linebuf);

/// =<<========== Legacy v1 API =============================================

}  // namespace tinyobj

#endif  // TINY_OBJ_LOADER_H_

#ifdef TINYOBJLOADER_IMPLEMENTATION
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <limits>
#include <set>
#include <sstream>
#include <utility>

#ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT

#ifdef TINYOBJLOADER_DONOT_INCLUDE_MAPBOX_EARCUT
// Assume earcut.hpp is included outside of tiny_obj_loader.h
#else

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"
#endif

#include <array>
#include "mapbox/earcut.hpp"

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif

#endif  // TINYOBJLOADER_USE_MAPBOX_EARCUT

namespace tinyobj {

MaterialReader::~MaterialReader() {}

struct vertex_index_t {
  int v_idx, vt_idx, vn_idx;
  vertex_index_t() : v_idx(-1), vt_idx(-1), vn_idx(-1) {}
  explicit vertex_index_t(int idx) : v_idx(idx), vt_idx(idx), vn_idx(idx) {}
  vertex_index_t(int vidx, int vtidx, int vnidx)
      : v_idx(vidx), vt_idx(vtidx), vn_idx(vnidx) {}
};

// Internal data structure for face representation
// index + smoothing group.
struct face_t {
  unsigned int
      smoothing_group_id;  // smoothing group id. 0 = smoothing groupd is off.
  int pad_;
  std::vector<vertex_index_t> vertex_indices;  // face vertex indices.

  face_t() : smoothing_group_id(0), pad_(0) {}
};

// Internal data structure for line representation
struct __line_t {
  // l v1/vt1 v2/vt2 ...
  // In the specification, line primitrive does not have normal index, but
  // TinyObjLoader allow it
  std::vector<vertex_index_t> vertex_indices;
};

// Internal data structure for points representation
struct __points_t {
  // p v1 v2 ...
  // In the specification, point primitrive does not have normal index and
  // texture coord index, but TinyObjLoader allow it.
  std::vector<vertex_index_t> vertex_indices;
};

struct tag_sizes {
  tag_sizes() : num_ints(0), num_reals(0), num_strings(0) {}
  int num_ints;
  int num_reals;
  int num_strings;
};

struct obj_shape {
  std::vector<real_t> v;
  std::vector<real_t> vn;
  std::vector<real_t> vt;
};

//
// Manages group of primitives(face, line, points, ...)
struct PrimGroup {
  std::vector<face_t> faceGroup;
  std::vector<__line_t> lineGroup;
  std::vector<__points_t> pointsGroup;

  void clear() {
    faceGroup.clear();
    lineGroup.clear();
    pointsGroup.clear();
  }

  bool IsEmpty() const {
    return faceGroup.empty() && lineGroup.empty() && pointsGroup.empty();
  }

  // TODO(syoyo): bspline, surface, ...
};

// See
// http://stackoverflow.com/questions/6089231/getting-std-ifstream-to-handle-lf-cr-and-crlf
static std::istream &safeGetline(std::istream &is, std::string &t) {
  t.clear();

  // The characters in the stream are read one-by-one using a std::streambuf.
  // That is faster than reading them one-by-one using the std::istream.
  // Code that uses streambuf this way must be guarded by a sentry object.
  // The sentry object performs various tasks,
  // such as thread synchronization and updating the stream state.

  std::istream::sentry se(is, true);
  std::streambuf *sb = is.rdbuf();

  if (se) {
    for (;;) {
      int c = sb->sbumpc();
      switch (c) {
        case '\n':
          return is;
        case '\r':
          if (sb->sgetc() == '\n') sb->sbumpc();
          return is;
        case EOF:
          // Also handle the case when the last line has no line ending
          if (t.empty()) is.setstate(std::ios::eofbit);
          return is;
        default:
          t += static_cast<char>(c);
      }
    }
  }

  return is;
}

#define IS_SPACE(x) (((x) == ' ') || ((x) == '\t'))
#define IS_DIGIT(x) \
  (static_cast<unsigned int>((x) - '0') < static_cast<unsigned int>(10))
#define IS_NEW_LINE(x) (((x) == '\r') || ((x) == '\n') || ((x) == '\0'))

template <typename T>
static inline std::string toString(const T &t) {
  std::stringstream ss;
  ss << t;
  return ss.str();
}

struct warning_context
{
	std::string *warn;
	size_t line_number;
};

// Make index zero-base, and also support relative index.
static inline bool fixIndex(int idx, int n, int *ret, bool allow_zero, const warning_context &context) {
  if (!ret) {
    return false;
  }

  if (idx > 0) {
    (*ret) = idx - 1;
    return true;
  }

  if (idx == 0) {
    // zero is not allowed according to the spec.
    if (context.warn) {
      (*context.warn) += "A zero value index found (will have a value of -1 for normal and tex indices. Line "
          + toString(context.line_number) + ").\n";
    }

    (*ret) = idx - 1;
    return allow_zero;
  }

  if (idx < 0) {
    (*ret) = n + idx;  // negative value = relative
    if((*ret) < 0){
      return false;  // invalid relative index
    }
    return true;
  }

  return false;  // never reach here.
}

static inline std::string parseString(const char **token) {
  std::string s;
  (*token) += strspn((*token), " \t");
  size_t e = strcspn((*token), " \t\r");
  s = std::string((*token), &(*token)[e]);
  (*token) += e;
  return s;
}

static inline int parseInt(const char **token) {
  (*token) += strspn((*token), " \t");
  int i = atoi((*token));
  (*token) += strcspn((*token), " \t\r");
  return i;
}

// Tries to parse a floating point number located at s.
//
// s_end should be a location in the string where reading should absolutely
// stop. For example at the end of the string, to prevent buffer overflows.
//
// Parses the following EBNF grammar:
//   sign    = "+" | "-" ;
//   END     = ? anything not in digit ?
//   digit   = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
//   integer = [sign] , digit , {digit} ;
//   decimal = integer , ["." , integer] ;
//   float   = ( decimal , END ) | ( decimal , ("E" | "e") , integer , END ) ;
//
//  Valid strings are for example:
//   -0  +3.1417e+2  -0.0E-3  1.0324  -1.41   11e2
//
// If the parsing is a success, result is set to the parsed value and true
// is returned.
//
// The function is greedy and will parse until any of the following happens:
//  - a non-conforming character is encountered.
//  - s_end is reached.
//
// The following situations triggers a failure:
//  - s >= s_end.
//  - parse failure.
//
static bool tryParseDouble(const char *s, const char *s_end, double *result) {
  if (s >= s_end) {
    return false;
  }

  double mantissa = 0.0;
  // This exponent is base 2 rather than 10.
  // However the exponent we parse is supposed to be one of ten,
  // thus we must take care to convert the exponent/and or the
  // mantissa to a * 2^E, where a is the mantissa and E is the
  // exponent.
  // To get the final double we will use ldexp, it requires the
  // exponent to be in base 2.
  int exponent = 0;

  // NOTE: THESE MUST BE DECLARED HERE SINCE WE ARE NOT ALLOWED
  // TO JUMP OVER DEFINITIONS.
  char sign = '+';
  char exp_sign = '+';
  char const *curr = s;

  // How many characters were read in a loop.
  int read = 0;
  // Tells whether a loop terminated due to reaching s_end.
  bool end_not_reached = false;
  bool leading_decimal_dots = false;

  /*
          BEGIN PARSING.
  */

  // Find out what sign we've got.
  if (*curr == '+' || *curr == '-') {
    sign = *curr;
    curr++;
    if ((curr != s_end) && (*curr == '.')) {
      // accept. Somethig like `.7e+2`, `-.5234`
      leading_decimal_dots = true;
    }
  } else if (IS_DIGIT(*curr)) { /* Pass through. */
  } else if (*curr == '.') {
    // accept. Somethig like `.7e+2`, `-.5234`
    leading_decimal_dots = true;
  } else {
    goto fail;
  }

  // Read the integer part.
  end_not_reached = (curr != s_end);
  if (!leading_decimal_dots) {
    while (end_not_reached && IS_DIGIT(*curr)) {
      mantissa *= 10;
      mantissa += static_cast<int>(*curr - 0x30);
      curr++;
      read++;
      end_not_reached = (curr != s_end);
    }

    // We must make sure we actually got something.
    if (read == 0) goto fail;
  }

  // We allow numbers of form "#", "###" etc.
  if (!end_not_reached) goto assemble;

  // Read the decimal part.
  if (*curr == '.') {
    curr++;
    read = 1;
    end_not_reached = (curr != s_end);
    while (end_not_reached && IS_DIGIT(*curr)) {
      static const double pow_lut[] = {
          1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 0.0000001,
      };
      const int lut_entries = sizeof pow_lut / sizeof pow_lut[0];

      // NOTE: Don't use powf here, it will absolutely murder precision.
      mantissa += static_cast<int>(*curr - 0x30) *
                  (read < lut_entries ? pow_lut[read] : std::pow(10.0, -read));
      read++;
      curr++;
      end_not_reached = (curr != s_end);
    }
  } else if (*curr == 'e' || *curr == 'E') {
  } else {
    goto assemble;
  }

  if (!end_not_reached) goto assemble;

  // Read the exponent part.
  if (*curr == 'e' || *curr == 'E') {
    curr++;
    // Figure out if a sign is present and if it is.
    end_not_reached = (curr != s_end);
    if (end_not_reached && (*curr == '+' || *curr == '-')) {
      exp_sign = *curr;
      curr++;
    } else if (IS_DIGIT(*curr)) { /* Pass through. */
    } else {
      // Empty E is not allowed.
      goto fail;
    }

    read = 0;
    end_not_reached = (curr != s_end);
    while (end_not_reached && IS_DIGIT(*curr)) {
      // To avoid annoying MSVC's min/max macro definiton,
      // Use hardcoded int max value
      if (exponent > (2147483647/10)) { // 2147483647 = std::numeric_limits<int>::max()
        // Integer overflow
        goto fail;
      }
      exponent *= 10;
      exponent += static_cast<int>(*curr - 0x30);
      curr++;
      read++;
      end_not_reached = (curr != s_end);
    }
    exponent *= (exp_sign == '+' ? 1 : -1);
    if (read == 0) goto fail;
  }

assemble:
  *result = (sign == '+' ? 1 : -1) *
            (exponent ? std::ldexp(mantissa * std::pow(5.0, exponent), exponent)
                      : mantissa);
  return true;
fail:
  return false;
}

static inline real_t parseReal(const char **token, double default_value = 0.0) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");
  double val = default_value;
  tryParseDouble((*token), end, &val);
  real_t f = static_cast<real_t>(val);
  (*token) = end;
  return f;
}

static inline bool parseReal(const char **token, real_t *out) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");
  double val;
  bool ret = tryParseDouble((*token), end, &val);
  if (ret) {
    real_t f = static_cast<real_t>(val);
    (*out) = f;
  }
  (*token) = end;
  return ret;
}

static inline void parseReal2(real_t *x, real_t *y, const char **token,
                              const double default_x = 0.0,
                              const double default_y = 0.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
}

static inline void parseReal3(real_t *x, real_t *y, real_t *z,
                              const char **token, const double default_x = 0.0,
                              const double default_y = 0.0,
                              const double default_z = 0.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
  (*z) = parseReal(token, default_z);
}

static inline void parseV(real_t *x, real_t *y, real_t *z, real_t *w,
                          const char **token, const double default_x = 0.0,
                          const double default_y = 0.0,
                          const double default_z = 0.0,
                          const double default_w = 1.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
  (*z) = parseReal(token, default_z);
  (*w) = parseReal(token, default_w);
}

// Extension: parse vertex with colors(6 items)
static inline bool parseVertexWithColor(real_t *x, real_t *y, real_t *z,
                                        real_t *r, real_t *g, real_t *b,
                                        const char **token,
                                        const double default_x = 0.0,
                                        const double default_y = 0.0,
                                        const double default_z = 0.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
  (*z) = parseReal(token, default_z);

  const bool found_color =
      parseReal(token, r) && parseReal(token, g) && parseReal(token, b);

  if (!found_color) {
    (*r) = (*g) = (*b) = 1.0;
  }

  return found_color;
}

static inline bool parseOnOff(const char **token, bool default_value = true) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");

  bool ret = default_value;
  if ((0 == strncmp((*token), "on", 2))) {
    ret = true;
  } else if ((0 == strncmp((*token), "off", 3))) {
    ret = false;
  }

  (*token) = end;
  return ret;
}

static inline texture_type_t parseTextureType(
    const char **token, texture_type_t default_value = TEXTURE_TYPE_NONE) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");
  texture_type_t ty = default_value;

  if ((0 == strncmp((*token), "cube_top", strlen("cube_top")))) {
    ty = TEXTURE_TYPE_CUBE_TOP;
  } else if ((0 == strncmp((*token), "cube_bottom", strlen("cube_bottom")))) {
    ty = TEXTURE_TYPE_CUBE_BOTTOM;
  } else if ((0 == strncmp((*token), "cube_left", strlen("cube_left")))) {
    ty = TEXTURE_TYPE_CUBE_LEFT;
  } else if ((0 == strncmp((*token), "cube_right", strlen("cube_right")))) {
    ty = TEXTURE_TYPE_CUBE_RIGHT;
  } else if ((0 == strncmp((*token), "cube_front", strlen("cube_front")))) {
    ty = TEXTURE_TYPE_CUBE_FRONT;
  } else if ((0 == strncmp((*token), "cube_back", strlen("cube_back")))) {
    ty = TEXTURE_TYPE_CUBE_BACK;
  } else if ((0 == strncmp((*token), "sphere", strlen("sphere")))) {
    ty = TEXTURE_TYPE_SPHERE;
  }

  (*token) = end;
  return ty;
}

static tag_sizes parseTagTriple(const char **token) {
  tag_sizes ts;

  (*token) += strspn((*token), " \t");
  ts.num_ints = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return ts;
  }

  (*token)++;  // Skip '/'

  (*token) += strspn((*token), " \t");
  ts.num_reals = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return ts;
  }
  (*token)++;  // Skip '/'

  ts.num_strings = parseInt(token);

  return ts;
}

// Parse triples with index offsets: i, i/j/k, i//k, i/j
static bool parseTriple(const char **token, int vsize, int vnsize, int vtsize,
                        vertex_index_t *ret, const warning_context &context) {
  if (!ret) {
    return false;
  }

  vertex_index_t vi(-1);

  if (!fixIndex(atoi((*token)), vsize, &vi.v_idx, false, context)) {
    return false;
  }

  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    (*ret) = vi;
    return true;
  }
  (*token)++;

  // i//k
  if ((*token)[0] == '/') {
    (*token)++;
    if (!fixIndex(atoi((*token)), vnsize, &vi.vn_idx, true, context)) {
      return false;
    }
    (*token) += strcspn((*token), "/ \t\r");
    (*ret) = vi;
    return true;
  }

  // i/j/k or i/j
  if (!fixIndex(atoi((*token)), vtsize, &vi.vt_idx, true, context)) {
    return false;
  }

  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    (*ret) = vi;
    return true;
  }

  // i/j/k
  (*token)++;  // skip '/'
  if (!fixIndex(atoi((*token)), vnsize, &vi.vn_idx, true, context)) {
    return false;
  }
  (*token) += strcspn((*token), "/ \t\r");

  (*ret) = vi;

  return true;
}

// Parse raw triples: i, i/j/k, i//k, i/j
static vertex_index_t parseRawTriple(const char **token) {
  vertex_index_t vi(static_cast<int>(0));  // 0 is an invalid index in OBJ

  vi.v_idx = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return vi;
  }
  (*token)++;

  // i//k
  if ((*token)[0] == '/') {
    (*token)++;
    vi.vn_idx = atoi((*token));
    (*token) += strcspn((*token), "/ \t\r");
    return vi;
  }

  // i/j/k or i/j
  vi.vt_idx = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return vi;
  }

  // i/j/k
  (*token)++;  // skip '/'
  vi.vn_idx = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  return vi;
}

bool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,
                               const char *linebuf) {
  // @todo { write more robust lexer and parser. }
  bool found_texname = false;
  std::string texture_name;

  const char *token = linebuf;  // Assume line ends with NULL

  while (!IS_NEW_LINE((*token))) {
    token += strspn(token, " \t");  // skip space
    if ((0 == strncmp(token, "-blendu", 7)) && IS_SPACE((token[7]))) {
      token += 8;
      texopt->blendu = parseOnOff(&token, /* default */ true);
    } else if ((0 == strncmp(token, "-blendv", 7)) && IS_SPACE((token[7]))) {
      token += 8;
      texopt->blendv = parseOnOff(&token, /* default */ true);
    } else if ((0 == strncmp(token, "-clamp", 6)) && IS_SPACE((token[6]))) {
      token += 7;
      texopt->clamp = parseOnOff(&token, /* default */ true);
    } else if ((0 == strncmp(token, "-boost", 6)) && IS_SPACE((token[6]))) {
      token += 7;
      texopt->sharpness = parseReal(&token, 1.0);
    } else if ((0 == strncmp(token, "-bm", 3)) && IS_SPACE((token[3]))) {
      token += 4;
      texopt->bump_multiplier = parseReal(&token, 1.0);
    } else if ((0 == strncmp(token, "-o", 2)) && IS_SPACE((token[2]))) {
      token += 3;
      parseReal3(&(texopt->origin_offset[0]), &(texopt->origin_offset[1]),
                 &(texopt->origin_offset[2]), &token);
    } else if ((0 == strncmp(token, "-s", 2)) && IS_SPACE((token[2]))) {
      token += 3;
      parseReal3(&(texopt->scale[0]), &(texopt->scale[1]), &(texopt->scale[2]),
                 &token, 1.0, 1.0, 1.0);
    } else if ((0 == strncmp(token, "-t", 2)) && IS_SPACE((token[2]))) {
      token += 3;
      parseReal3(&(texopt->turbulence[0]), &(texopt->turbulence[1]),
                 &(texopt->turbulence[2]), &token);
    } else if ((0 == strncmp(token, "-type", 5)) && IS_SPACE((token[5]))) {
      token += 5;
      texopt->type = parseTextureType((&token), TEXTURE_TYPE_NONE);
    } else if ((0 == strncmp(token, "-texres", 7)) && IS_SPACE((token[7]))) {
      token += 7;
      // TODO(syoyo): Check if arg is int type.
      texopt->texture_resolution = parseInt(&token);
    } else if ((0 == strncmp(token, "-imfchan", 8)) && IS_SPACE((token[8]))) {
      token += 9;
      token += strspn(token, " \t");
      const char *end = token + strcspn(token, " \t\r");
      if ((end - token) == 1) {  // Assume one char for -imfchan
        texopt->imfchan = (*token);
      }
      token = end;
    } else if ((0 == strncmp(token, "-mm", 3)) && IS_SPACE((token[3]))) {
      token += 4;
      parseReal2(&(texopt->brightness), &(texopt->contrast), &token, 0.0, 1.0);
    } else if ((0 == strncmp(token, "-colorspace", 11)) &&
               IS_SPACE((token[11]))) {
      token += 12;
      texopt->colorspace = parseString(&token);
    } else {
// Assume texture filename
#if 0
      size_t len = strcspn(token, " \t\r");  // untile next space
      texture_name = std::string(token, token + len);
      token += len;

      token += strspn(token, " \t");  // skip space
#else
      // Read filename until line end to parse filename containing whitespace
      // TODO(syoyo): Support parsing texture option flag after the filename.
      texture_name = std::string(token);
      token += texture_name.length();
#endif

      found_texname = true;
    }
  }

  if (found_texname) {
    (*texname) = texture_name;
    return true;
  } else {
    return false;
  }
}

static void InitTexOpt(texture_option_t *texopt, const bool is_bump) {
  if (is_bump) {
    texopt->imfchan = 'l';
  } else {
    texopt->imfchan = 'm';
  }
  texopt->bump_multiplier = static_cast<real_t>(1.0);
  texopt->clamp = false;
  texopt->blendu = true;
  texopt->blendv = true;
  texopt->sharpness = static_cast<real_t>(1.0);
  texopt->brightness = static_cast<real_t>(0.0);
  texopt->contrast = static_cast<real_t>(1.0);
  texopt->origin_offset[0] = static_cast<real_t>(0.0);
  texopt->origin_offset[1] = static_cast<real_t>(0.0);
  texopt->origin_offset[2] = static_cast<real_t>(0.0);
  texopt->scale[0] = static_cast<real_t>(1.0);
  texopt->scale[1] = static_cast<real_t>(1.0);
  texopt->scale[2] = static_cast<real_t>(1.0);
  texopt->turbulence[0] = static_cast<real_t>(0.0);
  texopt->turbulence[1] = static_cast<real_t>(0.0);
  texopt->turbulence[2] = static_cast<real_t>(0.0);
  texopt->texture_resolution = -1;
  texopt->type = TEXTURE_TYPE_NONE;
}

static void InitMaterial(material_t *material) {
  InitTexOpt(&material->ambient_texopt, /* is_bump */ false);
  InitTexOpt(&material->diffuse_texopt, /* is_bump */ false);
  InitTexOpt(&material->specular_texopt, /* is_bump */ false);
  InitTexOpt(&material->specular_highlight_texopt, /* is_bump */ false);
  InitTexOpt(&material->bump_texopt, /* is_bump */ true);
  InitTexOpt(&material->displacement_texopt, /* is_bump */ false);
  InitTexOpt(&material->alpha_texopt, /* is_bump */ false);
  InitTexOpt(&material->reflection_texopt, /* is_bump */ false);
  InitTexOpt(&material->roughness_texopt, /* is_bump */ false);
  InitTexOpt(&material->metallic_texopt, /* is_bump */ false);
  InitTexOpt(&material->sheen_texopt, /* is_bump */ false);
  InitTexOpt(&material->emissive_texopt, /* is_bump */ false);
  InitTexOpt(&material->normal_texopt,
             /* is_bump */ false);  // @fixme { is_bump will be true? }
  material->name = "";
  material->ambient_texname = "";
  material->diffuse_texname = "";
  material->specular_texname = "";
  material->specular_highlight_texname = "";
  material->bump_texname = "";
  material->displacement_texname = "";
  material->reflection_texname = "";
  material->alpha_texname = "";
  for (int i = 0; i < 3; i++) {
    material->ambient[i] = static_cast<real_t>(0.0);
    material->diffuse[i] = static_cast<real_t>(0.0);
    material->specular[i] = static_cast<real_t>(0.0);
    material->transmittance[i] = static_cast<real_t>(0.0);
    material->emission[i] = static_cast<real_t>(0.0);
  }
  material->illum = 0;
  material->dissolve = static_cast<real_t>(1.0);
  material->shininess = static_cast<real_t>(1.0);
  material->ior = static_cast<real_t>(1.0);

  material->roughness = static_cast<real_t>(0.0);
  material->metallic = static_cast<real_t>(0.0);
  material->sheen = static_cast<real_t>(0.0);
  material->clearcoat_thickness = static_cast<real_t>(0.0);
  material->clearcoat_roughness = static_cast<real_t>(0.0);
  material->anisotropy_rotation = static_cast<real_t>(0.0);
  material->anisotropy = static_cast<real_t>(0.0);
  material->roughness_texname = "";
  material->metallic_texname = "";
  material->sheen_texname = "";
  material->emissive_texname = "";
  material->normal_texname = "";

  material->unknown_parameter.clear();
}

// code from https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
template <typename T>
static int pnpoly(int nvert, T *vertx, T *verty, T testx, T testy) {
  int i, j, c = 0;
  for (i = 0, j = nvert - 1; i < nvert; j = i++) {
    if (((verty[i] > testy) != (verty[j] > testy)) &&
        (testx <
         (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) +
             vertx[i]))
      c = !c;
  }
  return c;
}

struct TinyObjPoint {
  real_t x, y, z;
  TinyObjPoint() : x(0), y(0), z(0) {}
  TinyObjPoint(real_t x_, real_t y_, real_t z_) :
    x(x_), y(y_), z(z_) {}
};

inline TinyObjPoint cross(const TinyObjPoint &v1, const TinyObjPoint &v2) {
  return TinyObjPoint(v1.y * v2.z - v1.z * v2.y,
                      v1.z * v2.x - v1.x * v2.z,
                      v1.x * v2.y - v1.y * v2.x);
}

inline real_t dot(const TinyObjPoint &v1, const TinyObjPoint &v2) {
  return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);
}

inline real_t GetLength(TinyObjPoint &e) {
	return std::sqrt(e.x*e.x + e.y*e.y + e.z*e.z);
}

inline TinyObjPoint Normalize(TinyObjPoint e) {
	real_t inv_length = real_t(1) / GetLength(e);
	return TinyObjPoint(e.x * inv_length, e.y * inv_length, e.z * inv_length );
}


inline TinyObjPoint WorldToLocal(const TinyObjPoint& a,
										  const TinyObjPoint& u,
										  const TinyObjPoint& v,
										  const TinyObjPoint& w) {
  return TinyObjPoint(dot(a,u),dot(a,v),dot(a,w));
}


// TODO(syoyo): refactor function.
static bool exportGroupsToShape(shape_t *shape, const PrimGroup &prim_group,
                                const std::vector<tag_t> &tags,
                                const int material_id, const std::string &name,
                                bool triangulate, const std::vector<real_t> &v,
                                std::string *warn) {
  if (prim_group.IsEmpty()) {
    return false;
  }

  shape->name = name;

  // polygon
  if (!prim_group.faceGroup.empty()) {
    // Flatten vertices and indices
    for (size_t i = 0; i < prim_group.faceGroup.size(); i++) {
      const face_t &face = prim_group.faceGroup[i];

      size_t npolys = face.vertex_indices.size();

      if (npolys < 3) {
        // Face must have 3+ vertices.
        if (warn) {
          (*warn) += "Degenerated face found\n.";
        }
        continue;
      }

      if (triangulate && npolys != 3) {
        if (npolys == 4) {
          vertex_index_t i0 = face.vertex_indices[0];
          vertex_index_t i1 = face.vertex_indices[1];
          vertex_index_t i2 = face.vertex_indices[2];
          vertex_index_t i3 = face.vertex_indices[3];

          size_t vi0 = size_t(i0.v_idx);
          size_t vi1 = size_t(i1.v_idx);
          size_t vi2 = size_t(i2.v_idx);
          size_t vi3 = size_t(i3.v_idx);

          if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||
              ((3 * vi2 + 2) >= v.size()) || ((3 * vi3 + 2) >= v.size())) {
            // Invalid triangle.
            // FIXME(syoyo): Is it ok to simply skip this invalid triangle?
            if (warn) {
              (*warn) += "Face with invalid vertex index found.\n";
            }
            continue;
          }

          real_t v0x = v[vi0 * 3 + 0];
          real_t v0y = v[vi0 * 3 + 1];
          real_t v0z = v[vi0 * 3 + 2];
          real_t v1x = v[vi1 * 3 + 0];
          real_t v1y = v[vi1 * 3 + 1];
          real_t v1z = v[vi1 * 3 + 2];
          real_t v2x = v[vi2 * 3 + 0];
          real_t v2y = v[vi2 * 3 + 1];
          real_t v2z = v[vi2 * 3 + 2];
          real_t v3x = v[vi3 * 3 + 0];
          real_t v3y = v[vi3 * 3 + 1];
          real_t v3z = v[vi3 * 3 + 2];

          // There are two candidates to split the quad into two triangles.
          //
          // Choose the shortest edge.
          // TODO: Is it better to determine the edge to split by calculating
          // the area of each triangle?
          //
          // +---+
          // |\  |
          // | \ |
          // |  \|
          // +---+
          //
          // +---+
          // |  /|
          // | / |
          // |/  |
          // +---+

          real_t e02x = v2x - v0x;
          real_t e02y = v2y - v0y;
          real_t e02z = v2z - v0z;
          real_t e13x = v3x - v1x;
          real_t e13y = v3y - v1y;
          real_t e13z = v3z - v1z;

          real_t sqr02 = e02x * e02x + e02y * e02y + e02z * e02z;
          real_t sqr13 = e13x * e13x + e13y * e13y + e13z * e13z;

          index_t idx0, idx1, idx2, idx3;

          idx0.vertex_index = i0.v_idx;
          idx0.normal_index = i0.vn_idx;
          idx0.texcoord_index = i0.vt_idx;
          idx1.vertex_index = i1.v_idx;
          idx1.normal_index = i1.vn_idx;
          idx1.texcoord_index = i1.vt_idx;
          idx2.vertex_index = i2.v_idx;
          idx2.normal_index = i2.vn_idx;
          idx2.texcoord_index = i2.vt_idx;
          idx3.vertex_index = i3.v_idx;
          idx3.normal_index = i3.vn_idx;
          idx3.texcoord_index = i3.vt_idx;

          if (sqr02 < sqr13) {
            // [0, 1, 2], [0, 2, 3]
            shape->mesh.indices.push_back(idx0);
            shape->mesh.indices.push_back(idx1);
            shape->mesh.indices.push_back(idx2);

            shape->mesh.indices.push_back(idx0);
            shape->mesh.indices.push_back(idx2);
            shape->mesh.indices.push_back(idx3);
          } else {
            // [0, 1, 3], [1, 2, 3]
            shape->mesh.indices.push_back(idx0);
            shape->mesh.indices.push_back(idx1);
            shape->mesh.indices.push_back(idx3);

            shape->mesh.indices.push_back(idx1);
            shape->mesh.indices.push_back(idx2);
            shape->mesh.indices.push_back(idx3);
          }

          // Two triangle faces
          shape->mesh.num_face_vertices.push_back(3);
          shape->mesh.num_face_vertices.push_back(3);

          shape->mesh.material_ids.push_back(material_id);
          shape->mesh.material_ids.push_back(material_id);

          shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);
          shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);

        } else {
#ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT
          vertex_index_t i0 = face.vertex_indices[0];
          vertex_index_t i0_2 = i0;

          // TMW change: Find the normal axis of the polygon using Newell's method
          TinyObjPoint n;
          for (size_t k = 0; k < npolys; ++k) {
            i0 = face.vertex_indices[k % npolys];
            size_t vi0 = size_t(i0.v_idx);

            size_t j = (k + 1) % npolys;
            i0_2 = face.vertex_indices[j];
            size_t vi0_2 = size_t(i0_2.v_idx);

            real_t v0x = v[vi0 * 3 + 0];
            real_t v0y = v[vi0 * 3 + 1];
            real_t v0z = v[vi0 * 3 + 2];

            real_t v0x_2 = v[vi0_2 * 3 + 0];
            real_t v0y_2 = v[vi0_2 * 3 + 1];
            real_t v0z_2 = v[vi0_2 * 3 + 2];

            const TinyObjPoint point1(v0x,v0y,v0z);
            const TinyObjPoint point2(v0x_2,v0y_2,v0z_2);

            TinyObjPoint a(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z);
            TinyObjPoint b(point1.x + point2.x, point1.y + point2.y, point1.z + point2.z);

            n.x += (a.y * b.z);
            n.y += (a.z * b.x);
            n.z += (a.x * b.y);
          }
          real_t length_n = GetLength(n);
          //Check if zero length normal
          if(length_n <= 0) {
            continue;
          }
          //Negative is to flip the normal to the correct direction
          real_t inv_length = -real_t(1.0) / length_n;
          n.x *= inv_length;
          n.y *= inv_length;
          n.z *= inv_length;

          TinyObjPoint axis_w, axis_v, axis_u;
          axis_w = n;
          TinyObjPoint a;
          if(std::abs(axis_w.x) > real_t(0.9999999)) {
            a = TinyObjPoint(0,1,0);
          } else {
            a = TinyObjPoint(1,0,0);
          }
          axis_v = Normalize(cross(axis_w, a));
          axis_u = cross(axis_w, axis_v);
          using Point = std::array<real_t, 2>;

          // first polyline define the main polygon.
          // following polylines define holes(not used in tinyobj).
          std::vector<std::vector<Point> > polygon;

          std::vector<Point> polyline;

          //TMW change: Find best normal and project v0x and v0y to those coordinates, instead of
          //picking a plane aligned with an axis (which can flip polygons).

          // Fill polygon data(facevarying vertices).
          for (size_t k = 0; k < npolys; k++) {
            i0 = face.vertex_indices[k];
            size_t vi0 = size_t(i0.v_idx);

            assert(((3 * vi0 + 2) < v.size()));

            real_t v0x = v[vi0 * 3 + 0];
            real_t v0y = v[vi0 * 3 + 1];
            real_t v0z = v[vi0 * 3 + 2];

            TinyObjPoint polypoint(v0x,v0y,v0z);
            TinyObjPoint loc = WorldToLocal(polypoint, axis_u, axis_v, axis_w);

            polyline.push_back({loc.x, loc.y});
          }

          polygon.push_back(polyline);
          std::vector<uint32_t> indices = mapbox::earcut<uint32_t>(polygon);
          // => result = 3 * faces, clockwise

          assert(indices.size() % 3 == 0);

          // Reconstruct vertex_index_t
          for (size_t k = 0; k < indices.size() / 3; k++) {
            {
              index_t idx0, idx1, idx2;
              idx0.vertex_index = face.vertex_indices[indices[3 * k + 0]].v_idx;
              idx0.normal_index =
                face.vertex_indices[indices[3 * k + 0]].vn_idx;
              idx0.texcoord_index =
                face.vertex_indices[indices[3 * k + 0]].vt_idx;
              idx1.vertex_index = face.vertex_indices[indices[3 * k + 1]].v_idx;
              idx1.normal_index =
                face.vertex_indices[indices[3 * k + 1]].vn_idx;
              idx1.texcoord_index =
                face.vertex_indices[indices[3 * k + 1]].vt_idx;
              idx2.vertex_index = face.vertex_indices[indices[3 * k + 2]].v_idx;
              idx2.normal_index =
                face.vertex_indices[indices[3 * k + 2]].vn_idx;
              idx2.texcoord_index =
                face.vertex_indices[indices[3 * k + 2]].vt_idx;

              shape->mesh.indices.push_back(idx0);
              shape->mesh.indices.push_back(idx1);
              shape->mesh.indices.push_back(idx2);

              shape->mesh.num_face_vertices.push_back(3);
              shape->mesh.material_ids.push_back(material_id);
              shape->mesh.smoothing_group_ids.push_back(
                  face.smoothing_group_id);
            }
          }

#else  // Built-in ear clipping triangulation
          vertex_index_t i0 = face.vertex_indices[0];
          vertex_index_t i1(-1);
          vertex_index_t i2 = face.vertex_indices[1];

          // find the two axes to work in
          size_t axes[2] = {1, 2};
          for (size_t k = 0; k < npolys; ++k) {
            i0 = face.vertex_indices[(k + 0) % npolys];
            i1 = face.vertex_indices[(k + 1) % npolys];
            i2 = face.vertex_indices[(k + 2) % npolys];
            size_t vi0 = size_t(i0.v_idx);
            size_t vi1 = size_t(i1.v_idx);
            size_t vi2 = size_t(i2.v_idx);

            if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||
                ((3 * vi2 + 2) >= v.size())) {
              // Invalid triangle.
              // FIXME(syoyo): Is it ok to simply skip this invalid triangle?
              continue;
            }
            real_t v0x = v[vi0 * 3 + 0];
            real_t v0y = v[vi0 * 3 + 1];
            real_t v0z = v[vi0 * 3 + 2];
            real_t v1x = v[vi1 * 3 + 0];
            real_t v1y = v[vi1 * 3 + 1];
            real_t v1z = v[vi1 * 3 + 2];
            real_t v2x = v[vi2 * 3 + 0];
            real_t v2y = v[vi2 * 3 + 1];
            real_t v2z = v[vi2 * 3 + 2];
            real_t e0x = v1x - v0x;
            real_t e0y = v1y - v0y;
            real_t e0z = v1z - v0z;
            real_t e1x = v2x - v1x;
            real_t e1y = v2y - v1y;
            real_t e1z = v2z - v1z;
            real_t cx = std::fabs(e0y * e1z - e0z * e1y);
            real_t cy = std::fabs(e0z * e1x - e0x * e1z);
            real_t cz = std::fabs(e0x * e1y - e0y * e1x);
            const real_t epsilon = std::numeric_limits<real_t>::epsilon();
            // std::cout << "cx " << cx << ", cy " << cy << ", cz " << cz <<
            // "\n";
            if (cx > epsilon || cy > epsilon || cz > epsilon) {
              // std::cout << "corner\n";
              // found a corner
              if (cx > cy && cx > cz) {
                // std::cout << "pattern0\n";
              } else {
                // std::cout << "axes[0] = 0\n";
                axes[0] = 0;
                if (cz > cx && cz > cy) {
                  // std::cout << "axes[1] = 1\n";
                  axes[1] = 1;
                }
              }
              break;
            }
          }

          face_t remainingFace = face;  // copy
          size_t guess_vert = 0;
          vertex_index_t ind[3];
          real_t vx[3];
          real_t vy[3];

          // How many iterations can we do without decreasing the remaining
          // vertices.
          size_t remainingIterations = face.vertex_indices.size();
          size_t previousRemainingVertices =
              remainingFace.vertex_indices.size();

          while (remainingFace.vertex_indices.size() > 3 &&
                 remainingIterations > 0) {
            // std::cout << "remainingIterations " << remainingIterations <<
            // "\n";

            npolys = remainingFace.vertex_indices.size();
            if (guess_vert >= npolys) {
              guess_vert -= npolys;
            }

            if (previousRemainingVertices != npolys) {
              // The number of remaining vertices decreased. Reset counters.
              previousRemainingVertices = npolys;
              remainingIterations = npolys;
            } else {
              // We didn't consume a vertex on previous iteration, reduce the
              // available iterations.
              remainingIterations--;
            }

            for (size_t k = 0; k < 3; k++) {
              ind[k] = remainingFace.vertex_indices[(guess_vert + k) % npolys];
              size_t vi = size_t(ind[k].v_idx);
              if (((vi * 3 + axes[0]) >= v.size()) ||
                  ((vi * 3 + axes[1]) >= v.size())) {
                // ???
                vx[k] = static_cast<real_t>(0.0);
                vy[k] = static_cast<real_t>(0.0);
              } else {
                vx[k] = v[vi * 3 + axes[0]];
                vy[k] = v[vi * 3 + axes[1]];
              }
            }

            //
            // area is calculated per face
            //
            real_t e0x = vx[1] - vx[0];
            real_t e0y = vy[1] - vy[0];
            real_t e1x = vx[2] - vx[1];
            real_t e1y = vy[2] - vy[1];
            real_t cross = e0x * e1y - e0y * e1x;
            // std::cout << "axes = " << axes[0] << ", " << axes[1] << "\n";
            // std::cout << "e0x, e0y, e1x, e1y " << e0x << ", " << e0y << ", "
            // << e1x << ", " << e1y << "\n";

            real_t area = (vx[0] * vy[1] - vy[0] * vx[1]) * static_cast<real_t>(0.5);
            // std::cout << "cross " << cross << ", area " << area << "\n";
            // if an internal angle
            if (cross * area < static_cast<real_t>(0.0)) {
              // std::cout << "internal \n";
              guess_vert += 1;
              // std::cout << "guess vert : " << guess_vert << "\n";
              continue;
            }

            // check all other verts in case they are inside this triangle
            bool overlap = false;
            for (size_t otherVert = 3; otherVert < npolys; ++otherVert) {
              size_t idx = (guess_vert + otherVert) % npolys;

              if (idx >= remainingFace.vertex_indices.size()) {
                // std::cout << "???0\n";
                // ???
                continue;
              }

              size_t ovi = size_t(remainingFace.vertex_indices[idx].v_idx);

              if (((ovi * 3 + axes[0]) >= v.size()) ||
                  ((ovi * 3 + axes[1]) >= v.size())) {
                // std::cout << "???1\n";
                // ???
                continue;
              }
              real_t tx = v[ovi * 3 + axes[0]];
              real_t ty = v[ovi * 3 + axes[1]];
              if (pnpoly(3, vx, vy, tx, ty)) {
                // std::cout << "overlap\n";
                overlap = true;
                break;
              }
            }

            if (overlap) {
              // std::cout << "overlap2\n";
              guess_vert += 1;
              continue;
            }

            // this triangle is an ear
            {
              index_t idx0, idx1, idx2;
              idx0.vertex_index = ind[0].v_idx;
              idx0.normal_index = ind[0].vn_idx;
              idx0.texcoord_index = ind[0].vt_idx;
              idx1.vertex_index = ind[1].v_idx;
              idx1.normal_index = ind[1].vn_idx;
              idx1.texcoord_index = ind[1].vt_idx;
              idx2.vertex_index = ind[2].v_idx;
              idx2.normal_index = ind[2].vn_idx;
              idx2.texcoord_index = ind[2].vt_idx;

              shape->mesh.indices.push_back(idx0);
              shape->mesh.indices.push_back(idx1);
              shape->mesh.indices.push_back(idx2);

              shape->mesh.num_face_vertices.push_back(3);
              shape->mesh.material_ids.push_back(material_id);
              shape->mesh.smoothing_group_ids.push_back(
                  face.smoothing_group_id);
            }

            // remove v1 from the list
            size_t removed_vert_index = (guess_vert + 1) % npolys;
            while (removed_vert_index + 1 < npolys) {
              remainingFace.vertex_indices[removed_vert_index] =
                  remainingFace.vertex_indices[removed_vert_index + 1];
              removed_vert_index += 1;
            }
            remainingFace.vertex_indices.pop_back();
          }

          // std::cout << "remainingFace.vi.size = " <<
          // remainingFace.vertex_indices.size() << "\n";
          if (remainingFace.vertex_indices.size() == 3) {
            i0 = remainingFace.vertex_indices[0];
            i1 = remainingFace.vertex_indices[1];
            i2 = remainingFace.vertex_indices[2];
            {
              index_t idx0, idx1, idx2;
              idx0.vertex_index = i0.v_idx;
              idx0.normal_index = i0.vn_idx;
              idx0.texcoord_index = i0.vt_idx;
              idx1.vertex_index = i1.v_idx;
              idx1.normal_index = i1.vn_idx;
              idx1.texcoord_index = i1.vt_idx;
              idx2.vertex_index = i2.v_idx;
              idx2.normal_index = i2.vn_idx;
              idx2.texcoord_index = i2.vt_idx;

              shape->mesh.indices.push_back(idx0);
              shape->mesh.indices.push_back(idx1);
              shape->mesh.indices.push_back(idx2);

              shape->mesh.num_face_vertices.push_back(3);
              shape->mesh.material_ids.push_back(material_id);
              shape->mesh.smoothing_group_ids.push_back(
                  face.smoothing_group_id);
            }
          }
#endif
        }  // npolys
      } else {
        for (size_t k = 0; k < npolys; k++) {
          index_t idx;
          idx.vertex_index = face.vertex_indices[k].v_idx;
          idx.normal_index = face.vertex_indices[k].vn_idx;
          idx.texcoord_index = face.vertex_indices[k].vt_idx;
          shape->mesh.indices.push_back(idx);
        }

        shape->mesh.num_face_vertices.push_back(
            static_cast<unsigned char>(npolys));
        shape->mesh.material_ids.push_back(material_id);  // per face
        shape->mesh.smoothing_group_ids.push_back(
            face.smoothing_group_id);  // per face
      }
    }

    shape->mesh.tags = tags;
  }

  // line
  if (!prim_group.lineGroup.empty()) {
    // Flatten indices
    for (size_t i = 0; i < prim_group.lineGroup.size(); i++) {
      for (size_t j = 0; j < prim_group.lineGroup[i].vertex_indices.size();
           j++) {
        const vertex_index_t &vi = prim_group.lineGroup[i].vertex_indices[j];

        index_t idx;
        idx.vertex_index = vi.v_idx;
        idx.normal_index = vi.vn_idx;
        idx.texcoord_index = vi.vt_idx;

        shape->lines.indices.push_back(idx);
      }

      shape->lines.num_line_vertices.push_back(
          int(prim_group.lineGroup[i].vertex_indices.size()));
    }
  }

  // points
  if (!prim_group.pointsGroup.empty()) {
    // Flatten & convert indices
    for (size_t i = 0; i < prim_group.pointsGroup.size(); i++) {
      for (size_t j = 0; j < prim_group.pointsGroup[i].vertex_indices.size();
           j++) {
        const vertex_index_t &vi = prim_group.pointsGroup[i].vertex_indices[j];

        index_t idx;
        idx.vertex_index = vi.v_idx;
        idx.normal_index = vi.vn_idx;
        idx.texcoord_index = vi.vt_idx;

        shape->points.indices.push_back(idx);
      }
    }
  }

  return true;
}

// Split a string with specified delimiter character and escape character.
// https://rosettacode.org/wiki/Tokenize_a_string_with_escaping#C.2B.2B
static void SplitString(const std::string &s, char delim, char escape,
                        std::vector<std::string> &elems) {
  std::string token;

  bool escaping = false;
  for (size_t i = 0; i < s.size(); ++i) {
    char ch = s[i];
    if (escaping) {
      escaping = false;
    } else if (ch == escape) {
      escaping = true;
      continue;
    } else if (ch == delim) {
      if (!token.empty()) {
        elems.push_back(token);
      }
      token.clear();
      continue;
    }
    token += ch;
  }

  elems.push_back(token);
}

static std::string JoinPath(const std::string &dir,
                            const std::string &filename) {
  if (dir.empty()) {
    return filename;
  } else {
    // check '/'
    char lastChar = *dir.rbegin();
    if (lastChar != '/') {
      return dir + std::string("/") + filename;
    } else {
      return dir + filename;
    }
  }
}

void LoadMtl(std::map<std::string, int> *material_map,
             std::vector<material_t> *materials, std::istream *inStream,
             std::string *warning, std::string *err) {
  (void)err;

  // Create a default material anyway.
  material_t material;
  InitMaterial(&material);

  // Issue 43. `d` wins against `Tr` since `Tr` is not in the MTL specification.
  bool has_d = false;
  bool has_tr = false;

  // has_kd is used to set a default diffuse value when map_Kd is present
  // and Kd is not.
  bool has_kd = false;

  std::stringstream warn_ss;

  size_t line_no = 0;
  std::string linebuf;
  while (inStream->peek() != -1) {
    safeGetline(*inStream, linebuf);
    line_no++;

    // Trim trailing whitespace.
    if (linebuf.size() > 0) {
      linebuf = linebuf.substr(0, linebuf.find_last_not_of(" \t") + 1);
    }

    // Trim newline '\r\n' or '\n'
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\n')
        linebuf.erase(linebuf.size() - 1);
    }
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\r')
        linebuf.erase(linebuf.size() - 1);
    }

    // Skip if empty line.
    if (linebuf.empty()) {
      continue;
    }

    // Skip leading space.
    const char *token = linebuf.c_str();
    token += strspn(token, " \t");

    assert(token);
    if (token[0] == '\0') continue;  // empty line

    if (token[0] == '#') continue;  // comment line

    // new mtl
    if ((0 == strncmp(token, "newmtl", 6)) && IS_SPACE((token[6]))) {
      // flush previous material.
      if (!material.name.empty()) {
        material_map->insert(std::pair<std::string, int>(
            material.name, static_cast<int>(materials->size())));
        materials->push_back(material);
      }

      // initial temporary material
      InitMaterial(&material);

      has_d = false;
      has_tr = false;

      // set new mtl name
      token += 7;
      {
        std::string namebuf = parseString(&token);
        // TODO: empty name check?
        if (namebuf.empty()) {
          if (warning) {
            (*warning) += "empty material name in `newmtl`\n";
          }
        }
        material.name = namebuf;
      }
      continue;
    }

    // ambient
    if (token[0] == 'K' && token[1] == 'a' && IS_SPACE((token[2]))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.ambient[0] = r;
      material.ambient[1] = g;
      material.ambient[2] = b;
      continue;
    }

    // diffuse
    if (token[0] == 'K' && token[1] == 'd' && IS_SPACE((token[2]))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.diffuse[0] = r;
      material.diffuse[1] = g;
      material.diffuse[2] = b;
      has_kd = true;
      continue;
    }

    // specular
    if (token[0] == 'K' && token[1] == 's' && IS_SPACE((token[2]))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.specular[0] = r;
      material.specular[1] = g;
      material.specular[2] = b;
      continue;
    }

    // transmittance
    if ((token[0] == 'K' && token[1] == 't' && IS_SPACE((token[2]))) ||
        (token[0] == 'T' && token[1] == 'f' && IS_SPACE((token[2])))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.transmittance[0] = r;
      material.transmittance[1] = g;
      material.transmittance[2] = b;
      continue;
    }

    // ior(index of refraction)
    if (token[0] == 'N' && token[1] == 'i' && IS_SPACE((token[2]))) {
      token += 2;
      material.ior = parseReal(&token);
      continue;
    }

    // emission
    if (token[0] == 'K' && token[1] == 'e' && IS_SPACE(token[2])) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.emission[0] = r;
      material.emission[1] = g;
      material.emission[2] = b;
      continue;
    }

    // shininess
    if (token[0] == 'N' && token[1] == 's' && IS_SPACE(token[2])) {
      token += 2;
      material.shininess = parseReal(&token);
      continue;
    }

    // illum model
    if (0 == strncmp(token, "illum", 5) && IS_SPACE(token[5])) {
      token += 6;
      material.illum = parseInt(&token);
      continue;
    }

    // dissolve
    if ((token[0] == 'd' && IS_SPACE(token[1]))) {
      token += 1;
      material.dissolve = parseReal(&token);

      if (has_tr) {
        warn_ss << "Both `d` and `Tr` parameters defined for \""
                << material.name
                << "\". Use the value of `d` for dissolve (line " << line_no
                << " in .mtl.)\n";
      }
      has_d = true;
      continue;
    }
    if (token[0] == 'T' && token[1] == 'r' && IS_SPACE(token[2])) {
      token += 2;
      if (has_d) {
        // `d` wins. Ignore `Tr` value.
        warn_ss << "Both `d` and `Tr` parameters defined for \""
                << material.name
                << "\". Use the value of `d` for dissolve (line " << line_no
                << " in .mtl.)\n";
      } else {
        // We invert value of Tr(assume Tr is in range [0, 1])
        // NOTE: Interpretation of Tr is application(exporter) dependent. For
        // some application(e.g. 3ds max obj exporter), Tr = d(Issue 43)
        material.dissolve = static_cast<real_t>(1.0) - parseReal(&token);
      }
      has_tr = true;
      continue;
    }

    // PBR: roughness
    if (token[0] == 'P' && token[1] == 'r' && IS_SPACE(token[2])) {
      token += 2;
      material.roughness = parseReal(&token);
      continue;
    }

    // PBR: metallic
    if (token[0] == 'P' && token[1] == 'm' && IS_SPACE(token[2])) {
      token += 2;
      material.metallic = parseReal(&token);
      continue;
    }

    // PBR: sheen
    if (token[0] == 'P' && token[1] == 's' && IS_SPACE(token[2])) {
      token += 2;
      material.sheen = parseReal(&token);
      continue;
    }

    // PBR: clearcoat thickness
    if (token[0] == 'P' && token[1] == 'c' && IS_SPACE(token[2])) {
      token += 2;
      material.clearcoat_thickness = parseReal(&token);
      continue;
    }

    // PBR: clearcoat roughness
    if ((0 == strncmp(token, "Pcr", 3)) && IS_SPACE(token[3])) {
      token += 4;
      material.clearcoat_roughness = parseReal(&token);
      continue;
    }

    // PBR: anisotropy
    if ((0 == strncmp(token, "aniso", 5)) && IS_SPACE(token[5])) {
      token += 6;
      material.anisotropy = parseReal(&token);
      continue;
    }

    // PBR: anisotropy rotation
    if ((0 == strncmp(token, "anisor", 6)) && IS_SPACE(token[6])) {
      token += 7;
      material.anisotropy_rotation = parseReal(&token);
      continue;
    }

    // ambient or ambient occlusion texture
    if ((0 == strncmp(token, "map_Ka", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.ambient_texname),
                                &(material.ambient_texopt), token);
      continue;
    }

    // diffuse texture
    if ((0 == strncmp(token, "map_Kd", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.diffuse_texname),
                                &(material.diffuse_texopt), token);

      // Set a decent diffuse default value if a diffuse texture is specified
      // without a matching Kd value.
      if (!has_kd) {
        material.diffuse[0] = static_cast<real_t>(0.6);
        material.diffuse[1] = static_cast<real_t>(0.6);
        material.diffuse[2] = static_cast<real_t>(0.6);
      }

      continue;
    }

    // specular texture
    if ((0 == strncmp(token, "map_Ks", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.specular_texname),
                                &(material.specular_texopt), token);
      continue;
    }

    // specular highlight texture
    if ((0 == strncmp(token, "map_Ns", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.specular_highlight_texname),
                                &(material.specular_highlight_texopt), token);
      continue;
    }

    // bump texture
    if (((0 == strncmp(token, "map_bump", 8)) ||
         (0 == strncmp(token, "map_Bump", 8))) &&
        IS_SPACE(token[8])) {
      token += 9;
      ParseTextureNameAndOption(&(material.bump_texname),
                                &(material.bump_texopt), token);
      continue;
    }

    // bump texture
    if ((0 == strncmp(token, "bump", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.bump_texname),
                                &(material.bump_texopt), token);
      continue;
    }

    // alpha texture
    if ((0 == strncmp(token, "map_d", 5)) && IS_SPACE(token[5])) {
      token += 6;
      material.alpha_texname = token;
      ParseTextureNameAndOption(&(material.alpha_texname),
                                &(material.alpha_texopt), token);
      continue;
    }

    // displacement texture
    if (((0 == strncmp(token, "map_disp", 8)) ||
         (0 == strncmp(token, "map_Disp", 8))) &&
        IS_SPACE(token[8])) {
      token += 9;
      ParseTextureNameAndOption(&(material.displacement_texname),
                                &(material.displacement_texopt), token);
      continue;
    }

    // displacement texture
    if ((0 == strncmp(token, "disp", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.displacement_texname),
                                &(material.displacement_texopt), token);
      continue;
    }

    // reflection map
    if ((0 == strncmp(token, "refl", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.reflection_texname),
                                &(material.reflection_texopt), token);
      continue;
    }

    // PBR: roughness texture
    if ((0 == strncmp(token, "map_Pr", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.roughness_texname),
                                &(material.roughness_texopt), token);
      continue;
    }

    // PBR: metallic texture
    if ((0 == strncmp(token, "map_Pm", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.metallic_texname),
                                &(material.metallic_texopt), token);
      continue;
    }

    // PBR: sheen texture
    if ((0 == strncmp(token, "map_Ps", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.sheen_texname),
                                &(material.sheen_texopt), token);
      continue;
    }

    // PBR: emissive texture
    if ((0 == strncmp(token, "map_Ke", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.emissive_texname),
                                &(material.emissive_texopt), token);
      continue;
    }

    // PBR: normal map texture
    if ((0 == strncmp(token, "norm", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.normal_texname),
                                &(material.normal_texopt), token);
      continue;
    }

    // unknown parameter
    const char *_space = strchr(token, ' ');
    if (!_space) {
      _space = strchr(token, '\t');
    }
    if (_space) {
      std::ptrdiff_t len = _space - token;
      std::string key(token, static_cast<size_t>(len));
      std::string value = _space + 1;
      material.unknown_parameter.insert(
          std::pair<std::string, std::string>(key, value));
    }
  }
  // flush last material.
  material_map->insert(std::pair<std::string, int>(
      material.name, static_cast<int>(materials->size())));
  materials->push_back(material);

  if (warning) {
    (*warning) = warn_ss.str();
  }
}

bool MaterialFileReader::operator()(const std::string &matId,
                                    std::vector<material_t> *materials,
                                    std::map<std::string, int> *matMap,
                                    std::string *warn, std::string *err) {
  if (!m_mtlBaseDir.empty()) {
#ifdef _WIN32
    char sep = ';';
#else
    char sep = ':';
#endif

    // https://stackoverflow.com/questions/5167625/splitting-a-c-stdstring-using-tokens-e-g
    std::vector<std::string> paths;
    std::istringstream f(m_mtlBaseDir);

    std::string s;
    while (getline(f, s, sep)) {
      paths.push_back(s);
    }

    for (size_t i = 0; i < paths.size(); i++) {
      std::string filepath = JoinPath(paths[i], matId);

      std::ifstream matIStream(filepath.c_str());
      if (matIStream) {
        LoadMtl(matMap, materials, &matIStream, warn, err);

        return true;
      }
    }

    std::stringstream ss;
    ss << "Material file [ " << matId
       << " ] not found in a path : " << m_mtlBaseDir << "\n";
    if (warn) {
      (*warn) += ss.str();
    }
    return false;

  } else {
    std::string filepath = matId;
    std::ifstream matIStream(filepath.c_str());
    if (matIStream) {
      LoadMtl(matMap, materials, &matIStream, warn, err);

      return true;
    }

    std::stringstream ss;
    ss << "Material file [ " << filepath
       << " ] not found in a path : " << m_mtlBaseDir << "\n";
    if (warn) {
      (*warn) += ss.str();
    }

    return false;
  }
}

bool MaterialStreamReader::operator()(const std::string &matId,
                                      std::vector<material_t> *materials,
                                      std::map<std::string, int> *matMap,
                                      std::string *warn, std::string *err) {
  (void)err;
  (void)matId;
  if (!m_inStream) {
    std::stringstream ss;
    ss << "Material stream in error state. \n";
    if (warn) {
      (*warn) += ss.str();
    }
    return false;
  }

  LoadMtl(matMap, materials, &m_inStream, warn, err);

  return true;
}

bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, const char *filename, const char *mtl_basedir,
             bool triangulate, bool default_vcols_fallback) {
  attrib->vertices.clear();
  attrib->normals.clear();
  attrib->texcoords.clear();
  attrib->colors.clear();
  shapes->clear();

  std::stringstream errss;

  std::ifstream ifs(filename);
  if (!ifs) {
    errss << "Cannot open file [" << filename << "]\n";
    if (err) {
      (*err) = errss.str();
    }
    return false;
  }

  std::string baseDir = mtl_basedir ? mtl_basedir : "";
  if (!baseDir.empty()) {
#ifndef _WIN32
    const char dirsep = '/';
#else
    const char dirsep = '\\';
#endif
    if (baseDir[baseDir.length() - 1] != dirsep) baseDir += dirsep;
  }
  MaterialFileReader matFileReader(baseDir);

  return LoadObj(attrib, shapes, materials, warn, err, &ifs, &matFileReader,
                 triangulate, default_vcols_fallback);
}

bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, std::istream *inStream,
             MaterialReader *readMatFn /*= NULL*/, bool triangulate,
             bool default_vcols_fallback) {
  std::stringstream errss;

  std::vector<real_t> v;
  std::vector<real_t> vn;
  std::vector<real_t> vt;
  std::vector<real_t> vc;
  std::vector<skin_weight_t> vw;
  std::vector<tag_t> tags;
  PrimGroup prim_group;
  std::string name;

  // material
  std::set<std::string> material_filenames;
  std::map<std::string, int> material_map;
  int material = -1;

  // smoothing group id
  unsigned int current_smoothing_id =
      0;  // Initial value. 0 means no smoothing.

  int greatest_v_idx = -1;
  int greatest_vn_idx = -1;
  int greatest_vt_idx = -1;

  shape_t shape;

  bool found_all_colors = true;

  size_t line_num = 0;
  std::string linebuf;
  while (inStream->peek() != -1) {
    safeGetline(*inStream, linebuf);

    line_num++;

    // Trim newline '\r\n' or '\n'
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\n')
        linebuf.erase(linebuf.size() - 1);
    }
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\r')
        linebuf.erase(linebuf.size() - 1);
    }

    // Skip if empty line.
    if (linebuf.empty()) {
      continue;
    }

    // Skip leading space.
    const char *token = linebuf.c_str();
    token += strspn(token, " \t");

    assert(token);
    if (token[0] == '\0') continue;  // empty line

    if (token[0] == '#') continue;  // comment line

    // vertex
    if (token[0] == 'v' && IS_SPACE((token[1]))) {
      token += 2;
      real_t x, y, z;
      real_t r, g, b;

      found_all_colors &= parseVertexWithColor(&x, &y, &z, &r, &g, &b, &token);

      v.push_back(x);
      v.push_back(y);
      v.push_back(z);

      if (found_all_colors || default_vcols_fallback) {
        vc.push_back(r);
        vc.push_back(g);
        vc.push_back(b);
      }

      continue;
    }

    // normal
    if (token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y, z;
      parseReal3(&x, &y, &z, &token);
      vn.push_back(x);
      vn.push_back(y);
      vn.push_back(z);
      continue;
    }

    // texcoord
    if (token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y;
      parseReal2(&x, &y, &token);
      vt.push_back(x);
      vt.push_back(y);
      continue;
    }

    // skin weight. tinyobj extension
    if (token[0] == 'v' && token[1] == 'w' && IS_SPACE((token[2]))) {
      token += 3;

      // vw <vid> <joint_0> <weight_0> <joint_1> <weight_1> ...
      // example:
      // vw 0 0 0.25 1 0.25 2 0.5

      // TODO(syoyo): Add syntax check
      int vid = 0;
      vid = parseInt(&token);

      skin_weight_t sw;

      sw.vertex_id = vid;

      while (!IS_NEW_LINE(token[0])) {
        real_t j, w;
        // joint_id should not be negative, weight may be negative
        // TODO(syoyo): # of elements check
        parseReal2(&j, &w, &token, -1.0);

        if (j < static_cast<real_t>(0)) {
          if (err) {
            std::stringstream ss;
            ss << "Failed parse `vw' line. joint_id is negative. "
                  "line "
               << line_num << ".)\n";
            (*err) += ss.str();
          }
          return false;
        }

        joint_and_weight_t jw;

        jw.joint_id = int(j);
        jw.weight = w;

        sw.weightValues.push_back(jw);

        size_t n = strspn(token, " \t\r");
        token += n;
      }

      vw.push_back(sw);
    }

    warning_context context;
    context.warn = warn;
    context.line_number = line_num;

    // line
    if (token[0] == 'l' && IS_SPACE((token[1]))) {
      token += 2;

      __line_t line;

      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi;
        if (!parseTriple(&token, static_cast<int>(v.size() / 3),
                         static_cast<int>(vn.size() / 3),
                         static_cast<int>(vt.size() / 2), &vi, context)) {
          if (err) {
            (*err) += "Failed to parse `l' line (e.g. a zero value for vertex index. Line " +
                toString(line_num) + ").\n";
          }
          return false;
        }

        line.vertex_indices.push_back(vi);

        size_t n = strspn(token, " \t\r");
        token += n;
      }

      prim_group.lineGroup.push_back(line);

      continue;
    }

    // points
    if (token[0] == 'p' && IS_SPACE((token[1]))) {
      token += 2;

      __points_t pts;

      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi;
        if (!parseTriple(&token, static_cast<int>(v.size() / 3),
                         static_cast<int>(vn.size() / 3),
                         static_cast<int>(vt.size() / 2), &vi, context)) {
          if (err) {
            (*err) += "Failed to parse `p' line (e.g. a zero value for vertex index. Line " +
                toString(line_num) + ").\n";
          }
          return false;
        }

        pts.vertex_indices.push_back(vi);

        size_t n = strspn(token, " \t\r");
        token += n;
      }

      prim_group.pointsGroup.push_back(pts);

      continue;
    }

    // face
    if (token[0] == 'f' && IS_SPACE((token[1]))) {
      token += 2;
      token += strspn(token, " \t");

      face_t face;

      face.smoothing_group_id = current_smoothing_id;
      face.vertex_indices.reserve(3);

      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi;
        if (!parseTriple(&token, static_cast<int>(v.size() / 3),
                         static_cast<int>(vn.size() / 3),
                         static_cast<int>(vt.size() / 2), &vi, context)) {
          if (err) {
            (*err) += "Failed to parse `f' line (e.g. a zero value for vertex index or invalid relative vertex index). Line " +
                toString(line_num) + ").\n";
          }
          return false;
        }

        greatest_v_idx = greatest_v_idx > vi.v_idx ? greatest_v_idx : vi.v_idx;
        greatest_vn_idx =
            greatest_vn_idx > vi.vn_idx ? greatest_vn_idx : vi.vn_idx;
        greatest_vt_idx =
            greatest_vt_idx > vi.vt_idx ? greatest_vt_idx : vi.vt_idx;

        face.vertex_indices.push_back(vi);
        size_t n = strspn(token, " \t\r");
        token += n;
      }

      // replace with emplace_back + std::move on C++11
      prim_group.faceGroup.push_back(face);

      continue;
    }

    // use mtl
    if ((0 == strncmp(token, "usemtl", 6))) {
      token += 6;
      std::string namebuf = parseString(&token);

      int newMaterialId = -1;
      std::map<std::string, int>::const_iterator it =
          material_map.find(namebuf);
      if (it != material_map.end()) {
        newMaterialId = it->second;
      } else {
        // { error!! material not found }
        if (warn) {
          (*warn) += "material [ '" + namebuf + "' ] not found in .mtl\n";
        }
      }

      if (newMaterialId != material) {
        // Create per-face material. Thus we don't add `shape` to `shapes` at
        // this time.
        // just clear `faceGroup` after `exportGroupsToShape()` call.
        exportGroupsToShape(&shape, prim_group, tags, material, name,
                            triangulate, v, warn);
        prim_group.faceGroup.clear();
        material = newMaterialId;
      }

      continue;
    }

    // load mtl
    if ((0 == strncmp(token, "mtllib", 6)) && IS_SPACE((token[6]))) {
      if (readMatFn) {
        token += 7;

        std::vector<std::string> filenames;
        SplitString(std::string(token), ' ', '\\', filenames);

        if (filenames.empty()) {
          if (warn) {
            std::stringstream ss;
            ss << "Looks like empty filename for mtllib. Use default "
                  "material (line "
               << line_num << ".)\n";

            (*warn) += ss.str();
          }
        } else {
          bool found = false;
          for (size_t s = 0; s < filenames.size(); s++) {
            if (material_filenames.count(filenames[s]) > 0) {
              found = true;
              continue;
            }

            std::string warn_mtl;
            std::string err_mtl;
            bool ok = (*readMatFn)(filenames[s].c_str(), materials,
                                   &material_map, &warn_mtl, &err_mtl);
            if (warn && (!warn_mtl.empty())) {
              (*warn) += warn_mtl;
            }

            if (err && (!err_mtl.empty())) {
              (*err) += err_mtl;
            }

            if (ok) {
              found = true;
              material_filenames.insert(filenames[s]);
              break;
            }
          }

          if (!found) {
            if (warn) {
              (*warn) +=
                  "Failed to load material file(s). Use default "
                  "material.\n";
            }
          }
        }
      }

      continue;
    }

    // group name
    if (token[0] == 'g' && IS_SPACE((token[1]))) {
      // flush previous face group.
      bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,
                                     triangulate, v, warn);
      (void)ret;  // return value not used.

      if (shape.mesh.indices.size() > 0) {
        shapes->push_back(shape);
      }

      shape = shape_t();

      // material = -1;
      prim_group.clear();

      std::vector<std::string> names;

      while (!IS_NEW_LINE(token[0])) {
        std::string str = parseString(&token);
        names.push_back(str);
        token += strspn(token, " \t\r");  // skip tag
      }

      // names[0] must be 'g'

      if (names.size() < 2) {
        // 'g' with empty names
        if (warn) {
          std::stringstream ss;
          ss << "Empty group name. line: " << line_num << "\n";
          (*warn) += ss.str();
          name = "";
        }
      } else {
        std::stringstream ss;
        ss << names[1];

        // tinyobjloader does not support multiple groups for a primitive.
        // Currently we concatinate multiple group names with a space to get
        // single group name.

        for (size_t i = 2; i < names.size(); i++) {
          ss << " " << names[i];
        }

        name = ss.str();
      }

      continue;
    }

    // object name
    if (token[0] == 'o' && IS_SPACE((token[1]))) {
      // flush previous face group.
      bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,
                                     triangulate, v, warn);
      (void)ret;  // return value not used.

      if (shape.mesh.indices.size() > 0 || shape.lines.indices.size() > 0 ||
          shape.points.indices.size() > 0) {
        shapes->push_back(shape);
      }

      // material = -1;
      prim_group.clear();
      shape = shape_t();

      // @todo { multiple object name? }
      token += 2;
      std::stringstream ss;
      ss << token;
      name = ss.str();

      continue;
    }

    if (token[0] == 't' && IS_SPACE(token[1])) {
      const int max_tag_nums = 8192;  // FIXME(syoyo): Parameterize.
      tag_t tag;

      token += 2;

      tag.name = parseString(&token);

      tag_sizes ts = parseTagTriple(&token);

      if (ts.num_ints < 0) {
        ts.num_ints = 0;
      }
      if (ts.num_ints > max_tag_nums) {
        ts.num_ints = max_tag_nums;
      }

      if (ts.num_reals < 0) {
        ts.num_reals = 0;
      }
      if (ts.num_reals > max_tag_nums) {
        ts.num_reals = max_tag_nums;
      }

      if (ts.num_strings < 0) {
        ts.num_strings = 0;
      }
      if (ts.num_strings > max_tag_nums) {
        ts.num_strings = max_tag_nums;
      }

      tag.intValues.resize(static_cast<size_t>(ts.num_ints));

      for (size_t i = 0; i < static_cast<size_t>(ts.num_ints); ++i) {
        tag.intValues[i] = parseInt(&token);
      }

      tag.floatValues.resize(static_cast<size_t>(ts.num_reals));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_reals); ++i) {
        tag.floatValues[i] = parseReal(&token);
      }

      tag.stringValues.resize(static_cast<size_t>(ts.num_strings));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_strings); ++i) {
        tag.stringValues[i] = parseString(&token);
      }

      tags.push_back(tag);

      continue;
    }

    if (token[0] == 's' && IS_SPACE(token[1])) {
      // smoothing group id
      token += 2;

      // skip space.
      token += strspn(token, " \t");  // skip space

      if (token[0] == '\0') {
        continue;
      }

      if (token[0] == '\r' || token[1] == '\n') {
        continue;
      }

      if (strlen(token) >= 3 && token[0] == 'o' && token[1] == 'f' &&
          token[2] == 'f') {
        current_smoothing_id = 0;
      } else {
        // assume number
        int smGroupId = parseInt(&token);
        if (smGroupId < 0) {
          // parse error. force set to 0.
          // FIXME(syoyo): Report warning.
          current_smoothing_id = 0;
        } else {
          current_smoothing_id = static_cast<unsigned int>(smGroupId);
        }
      }

      continue;
    }  // smoothing group id

    // Ignore unknown command.
  }

  // not all vertices have colors, no default colors desired? -> clear colors
  if (!found_all_colors && !default_vcols_fallback) {
    vc.clear();
  }

  if (greatest_v_idx >= static_cast<int>(v.size() / 3)) {
    if (warn) {
      std::stringstream ss;
      ss << "Vertex indices out of bounds (line " << line_num << ".)\n\n";
      (*warn) += ss.str();
    }
  }
  if (greatest_vn_idx >= static_cast<int>(vn.size() / 3)) {
    if (warn) {
      std::stringstream ss;
      ss << "Vertex normal indices out of bounds (line " << line_num << ".)\n\n";
      (*warn) += ss.str();
    }
  }
  if (greatest_vt_idx >= static_cast<int>(vt.size() / 2)) {
    if (warn) {
      std::stringstream ss;
      ss << "Vertex texcoord indices out of bounds (line " << line_num << ".)\n\n";
      (*warn) += ss.str();
    }
  }

  bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,
                                 triangulate, v, warn);
  // exportGroupsToShape return false when `usemtl` is called in the last
  // line.
  // we also add `shape` to `shapes` when `shape.mesh` has already some
  // faces(indices)
  if (ret || shape.mesh.indices
                 .size()) {  // FIXME(syoyo): Support other prims(e.g. lines)
    shapes->push_back(shape);
  }
  prim_group.clear();  // for safety

  if (err) {
    (*err) += errss.str();
  }

  attrib->vertices.swap(v);
  attrib->vertex_weights.swap(v);
  attrib->normals.swap(vn);
  attrib->texcoords.swap(vt);
  attrib->texcoord_ws.swap(vt);
  attrib->colors.swap(vc);
  attrib->skin_weights.swap(vw);

  return true;
}

bool LoadObjWithCallback(std::istream &inStream, const callback_t &callback,
                         void *user_data /*= NULL*/,
                         MaterialReader *readMatFn /*= NULL*/,
                         std::string *warn, /* = NULL*/
                         std::string *err /*= NULL*/) {
  std::stringstream errss;

  // material
  std::set<std::string> material_filenames;
  std::map<std::string, int> material_map;
  int material_id = -1;  // -1 = invalid

  std::vector<index_t> indices;
  std::vector<material_t> materials;
  std::vector<std::string> names;
  names.reserve(2);
  std::vector<const char *> names_out;

  std::string linebuf;
  while (inStream.peek() != -1) {
    safeGetline(inStream, linebuf);

    // Trim newline '\r\n' or '\n'
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\n')
        linebuf.erase(linebuf.size() - 1);
    }
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\r')
        linebuf.erase(linebuf.size() - 1);
    }

    // Skip if empty line.
    if (linebuf.empty()) {
      continue;
    }

    // Skip leading space.
    const char *token = linebuf.c_str();
    token += strspn(token, " \t");

    assert(token);
    if (token[0] == '\0') continue;  // empty line

    if (token[0] == '#') continue;  // comment line

    // vertex
    if (token[0] == 'v' && IS_SPACE((token[1]))) {
      token += 2;
      real_t x, y, z;
      real_t r, g, b;

      bool found_color = parseVertexWithColor(&x, &y, &z, &r, &g, &b, &token);
      if (callback.vertex_cb) {
        callback.vertex_cb(user_data, x, y, z, r);  // r=w is optional
      }
      if (callback.vertex_color_cb) {
        callback.vertex_color_cb(user_data, x, y, z, r, g, b, found_color);
      }
      continue;
    }

    // normal
    if (token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y, z;
      parseReal3(&x, &y, &z, &token);
      if (callback.normal_cb) {
        callback.normal_cb(user_data, x, y, z);
      }
      continue;
    }

    // texcoord
    if (token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y, z;  // y and z are optional. default = 0.0
      parseReal3(&x, &y, &z, &token);
      if (callback.texcoord_cb) {
        callback.texcoord_cb(user_data, x, y, z);
      }
      continue;
    }

    // face
    if (token[0] == 'f' && IS_SPACE((token[1]))) {
      token += 2;
      token += strspn(token, " \t");

      indices.clear();
      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi = parseRawTriple(&token);

        index_t idx;
        idx.vertex_index = vi.v_idx;
        idx.normal_index = vi.vn_idx;
        idx.texcoord_index = vi.vt_idx;

        indices.push_back(idx);
        size_t n = strspn(token, " \t\r");
        token += n;
      }

      if (callback.index_cb && indices.size() > 0) {
        callback.index_cb(user_data, &indices.at(0),
                          static_cast<int>(indices.size()));
      }

      continue;
    }

    // use mtl
    if ((0 == strncmp(token, "usemtl", 6)) && IS_SPACE((token[6]))) {
      token += 7;
      std::stringstream ss;
      ss << token;
      std::string namebuf = ss.str();

      int newMaterialId = -1;
      std::map<std::string, int>::const_iterator it =
          material_map.find(namebuf);
      if (it != material_map.end()) {
        newMaterialId = it->second;
      } else {
        // { warn!! material not found }
        if (warn && (!callback.usemtl_cb)) {
          (*warn) += "material [ " + namebuf + " ] not found in .mtl\n";
        }
      }

      if (newMaterialId != material_id) {
        material_id = newMaterialId;
      }

      if (callback.usemtl_cb) {
        callback.usemtl_cb(user_data, namebuf.c_str(), material_id);
      }

      continue;
    }

    // load mtl
    if ((0 == strncmp(token, "mtllib", 6)) && IS_SPACE((token[6]))) {
      if (readMatFn) {
        token += 7;

        std::vector<std::string> filenames;
        SplitString(std::string(token), ' ', '\\', filenames);

        if (filenames.empty()) {
          if (warn) {
            (*warn) +=
                "Looks like empty filename for mtllib. Use default "
                "material. \n";
          }
        } else {
          bool found = false;
          for (size_t s = 0; s < filenames.size(); s++) {
            if (material_filenames.count(filenames[s]) > 0) {
              found = true;
              continue;
            }

            std::string warn_mtl;
            std::string err_mtl;
            bool ok = (*readMatFn)(filenames[s].c_str(), &materials,
                                   &material_map, &warn_mtl, &err_mtl);

            if (warn && (!warn_mtl.empty())) {
              (*warn) += warn_mtl;  // This should be warn message.
            }

            if (err && (!err_mtl.empty())) {
              (*err) += err_mtl;
            }

            if (ok) {
              found = true;
              material_filenames.insert(filenames[s]);
              break;
            }
          }

          if (!found) {
            if (warn) {
              (*warn) +=
                  "Failed to load material file(s). Use default "
                  "material.\n";
            }
          } else {
            if (callback.mtllib_cb) {
              callback.mtllib_cb(user_data, &materials.at(0),
                                 static_cast<int>(materials.size()));
            }
          }
        }
      }

      continue;
    }

    // group name
    if (token[0] == 'g' && IS_SPACE((token[1]))) {
      names.clear();

      while (!IS_NEW_LINE(token[0])) {
        std::string str = parseString(&token);
        names.push_back(str);
        token += strspn(token, " \t\r");  // skip tag
      }

      assert(names.size() > 0);

      if (callback.group_cb) {
        if (names.size() > 1) {
          // create const char* array.
          names_out.resize(names.size() - 1);
          for (size_t j = 0; j < names_out.size(); j++) {
            names_out[j] = names[j + 1].c_str();
          }
          callback.group_cb(user_data, &names_out.at(0),
                            static_cast<int>(names_out.size()));

        } else {
          callback.group_cb(user_data, NULL, 0);
        }
      }

      continue;
    }

    // object name
    if (token[0] == 'o' && IS_SPACE((token[1]))) {
      // @todo { multiple object name? }
      token += 2;

      std::stringstream ss;
      ss << token;
      std::string object_name = ss.str();

      if (callback.object_cb) {
        callback.object_cb(user_data, object_name.c_str());
      }

      continue;
    }

#if 0  // @todo
    if (token[0] == 't' && IS_SPACE(token[1])) {
      tag_t tag;

      token += 2;
      std::stringstream ss;
      ss << token;
      tag.name = ss.str();

      token += tag.name.size() + 1;

      tag_sizes ts = parseTagTriple(&token);

      tag.intValues.resize(static_cast<size_t>(ts.num_ints));

      for (size_t i = 0; i < static_cast<size_t>(ts.num_ints); ++i) {
        tag.intValues[i] = atoi(token);
        token += strcspn(token, "/ \t\r") + 1;
      }

      tag.floatValues.resize(static_cast<size_t>(ts.num_reals));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_reals); ++i) {
        tag.floatValues[i] = parseReal(&token);
        token += strcspn(token, "/ \t\r") + 1;
      }

      tag.stringValues.resize(static_cast<size_t>(ts.num_strings));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_strings); ++i) {
        std::stringstream ss;
        ss << token;
        tag.stringValues[i] = ss.str();
        token += tag.stringValues[i].size() + 1;
      }

      tags.push_back(tag);
    }
#endif

    // Ignore unknown command.
  }

  if (err) {
    (*err) += errss.str();
  }

  return true;
}

bool ObjReader::ParseFromFile(const std::string &filename,
                              const ObjReaderConfig &config) {
  std::string mtl_search_path;

  if (config.mtl_search_path.empty()) {
    //
    // split at last '/'(for unixish system) or '\\'(for windows) to get
    // the base directory of .obj file
    //
    size_t pos = filename.find_last_of("/\\");
    if (pos != std::string::npos) {
      mtl_search_path = filename.substr(0, pos);
    }
  } else {
    mtl_search_path = config.mtl_search_path;
  }

  valid_ = LoadObj(&attrib_, &shapes_, &materials_, &warning_, &error_,
                   filename.c_str(), mtl_search_path.c_str(),
                   config.triangulate, config.vertex_color);

  return valid_;
}

bool ObjReader::ParseFromString(const std::string &obj_text,
                                const std::string &mtl_text,
                                const ObjReaderConfig &config) {
  std::stringbuf obj_buf(obj_text);
  std::stringbuf mtl_buf(mtl_text);

  std::istream obj_ifs(&obj_buf);
  std::istream mtl_ifs(&mtl_buf);

  MaterialStreamReader mtl_ss(mtl_ifs);

  valid_ = LoadObj(&attrib_, &shapes_, &materials_, &warning_, &error_,
                   &obj_ifs, &mtl_ss, config.triangulate, config.vertex_color);

  return valid_;
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif
}  // namespace tinyobj

#endif

================
File: LICENSE
================
MIT License

Copyright (c) 2023 Robert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# 3D-Software-Renderer

This is my software renderer. I set out to make one as I have always been interested in computer graphics and I also wanted to get better at using C++. It is a forward renderer with a full PBR pipeline that renders light and materials realistically using a Cook-Torrance BRDF and implements a fresnel effect using the fresnel schlick approximation.

It uses the barycentric method to rasterising the triangles and is fully parallelised for good performance and uses tangent space normal mappig. It renders roughly ~100k vertices at 30 fps at 1920 X 1080 resolution on a AMD Ryzen 5 5600x.

- [3D-Software-Renderer](#3d-software-renderer)
  - [Example Images](#example-images)
  - [Motivation](#motivation)
  - [Features](#features)
  - [Dependencies](#dependencies)
  - [What needs to be done](#what-needs-to-be-done)
  - [Resources I used](#resources-i-used)
  - [Assets](#assets)


## Example Images

## Motivation

I've always liked video games, ever since I was a child. Computer graphics fascinated me and I liked looking at pretty pictures in games. I wanted to combine that love of games and computer graphics with my skillset of C++. I wanted to achieve at least 30fps in a relatively large model at 1280 X 720. i have managed to exceed this goal by getting around 30 fps at 1920 X 1080. This was also my first large project and wanted a chance to practice architecting my program using Object Oriented Programming (OOP). I think overall this project has been a success for me and I am proud of what I have achieved.

## Features

- Fully parallelised forward barycentric rasteriser.
- Tangent space normal mapping
- A roughness-metallic PBR rendering pipeline using a programmable vertex and fragment shader.
- A basic scene loader 
- A basic triangle clipper
- A fully controllable camera
- Parallax occlusion mapping
- Backface culling
- Texture repeating
- Point light list with linear and quadratic attenuation.


## Dependencies
- SDL2
- SDL Image
- Tinyobjloader
- glm


## What needs to be done

- View frustum culling needs to be implemented, this will give big performance gains on multi model scenes.
- An implementation of SIMD intrinsics to further improve PBR performance in the shader.
- Reduce the amount of barycentric coordinate calculations in the rasteriser hot path.

## Resources I used
- [TinyRenderer](https://github.com/ssloy/tinyrenderer)
- Real Time Rendering by Akenine-Moller et al.
- [SSGE by Angel Ortiz](https://github.com/Angelo1211/SoftwareRenderer)
- Real-Time Collision Detection by Christer Ericson
- [ScratchAPixel](https://www.scratchapixel.com/)
- [LearnOpenGL](https://learnopengl.com/)

## Assets

================
File: src/camera.cpp
================
#include "camera.h"

Camera::Camera()
{
	fov = glm::radians(90.0f);
	nearPlane = 0.1f;
	farPlane = 1000.0f;
	perspective = glm::perspective(fov, (float)Display::SCREENWIDTH / Display::SCREENHEIGHT, nearPlane, farPlane);
	view = glm::lookAt(position, target, up);

	calculateFrustumPlanes();
}

Camera::~Camera(){}

// Calculate the frustum planes from the view matrix.
void Camera::calculateFrustumPlanes()
{
	glm::mat4x4 viewMatrix = getView();

	frustumPlanes.resize(6);

	// Calculate the near plane.
	glm::vec4 nearPlane = glm::vec4(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2], viewMatrix[3][2]);
	nearPlane /= glm::length(glm::vec3(nearPlane));

	// Calculate the far plane.
	glm::vec4 farPlane = glm::vec4(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2], -viewMatrix[3][2]);
	farPlane /= glm::length(glm::vec3(farPlane));

	// Calculate the left plane.
	glm::vec4 leftPlane = glm::vec4(viewMatrix[0][3] + viewMatrix[0][0], viewMatrix[1][3] + viewMatrix[1][0], viewMatrix[2][3] + viewMatrix[2][0], viewMatrix[3][3] + viewMatrix[3][0]);
	leftPlane /= glm::length(glm::vec3(leftPlane));

	// Calculate the right plane.
	glm::vec4 rightPlane = glm::vec4(viewMatrix[0][3] - viewMatrix[0][0], viewMatrix[1][3] - viewMatrix[1][0], viewMatrix[2][3] - viewMatrix[2][0], viewMatrix[3][3] - viewMatrix[3][0]);
	rightPlane /= glm::length(glm::vec3(rightPlane));

	// Calculate the top plane.
	glm::vec4 topPlane = glm::vec4(viewMatrix[0][3] - viewMatrix[0][1], viewMatrix[1][3] - viewMatrix[1][1], viewMatrix[2][3] - viewMatrix[2][1], viewMatrix[3][3] - viewMatrix[3][1]);
	topPlane /= glm::length(glm::vec3(topPlane));

	// Calculate the bottom plane.
	glm::vec4 bottomPlane = glm::vec4(viewMatrix[0][3] + viewMatrix[0][1], viewMatrix[1][3] + viewMatrix[1][1], viewMatrix[2][3] + viewMatrix[2][1], viewMatrix[3][3] + viewMatrix[3][1]);
	bottomPlane /= glm::length(glm::vec3(bottomPlane));

	// Set the frustum planes.
	frustumPlanes[0] = nearPlane;
	frustumPlanes[1] = farPlane;
	frustumPlanes[2] = leftPlane;
	frustumPlanes[3] = rightPlane;
	frustumPlanes[4] = topPlane;
	frustumPlanes[5] = bottomPlane;
}


void Camera::UpdateView(glm::vec3 newPos)
{
	view = glm::lookAt(position, position + front, up);
	calculateFrustumPlanes();
}

void Camera::MoveForward(float delta)
{
	position += front * delta;
	UpdateView(position);
}

void Camera::MoveBackward(float delta)
{
	position -= front * delta;
	UpdateView(position);
}

void Camera::StrafeLeft(float delta)
{
	glm::vec3 right = glm::normalize(glm::cross(front, up));
	position -= right * delta;
	UpdateView(position);
}

void Camera::StrafeRight(float delta)
{
	glm::vec3 right = glm::normalize(glm::cross(front, up));
	position += right * delta;
	UpdateView(position);
}

//Handles the rotation of the front vector to allow for mouse control of camera
void Camera::RotateCamera(float deltaYaw, float deltaPitch) 
{
	yaw += deltaYaw;
	pitch += deltaPitch;

	// Limit the pitch angle to avoid gimbal lock
	if (pitch > 89.0f) {
		pitch = 89.0f;
	}
	if (pitch < -89.0f) {
		pitch = -89.0f;
	}

	// Calculate the new front vector based on the updated yaw and pitch angles
	glm::vec3 newFront;
	newFront.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
	newFront.y = sin(glm::radians(pitch));
	newFront.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
	front = glm::normalize(newFront);

	// Update the view matrix
	view = glm::lookAt(position, position + front, up);
}

================
File: src/display.cpp
================
#include "display.h"
#include <cstring>

Display::Display(){}

Display::~Display(){}

bool Display::StartUp()
{
    bool success = true;

    // Initialize SDL2
    if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize SDL2: %s", SDL_GetError());
        success = false;
        return success;
    }
    // Create a window
    mWindow = SDL_CreateWindow("3D Software Renderer",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        SCREENWIDTH, SCREENHEIGHT,
        SDL_WINDOW_SHOWN);
    if (mWindow == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create SDL2 window: %s", SDL_GetError());
        SDL_Quit();
        success = false;
        return success;
    }

    //Create surface
    mSurface = SDL_GetWindowSurface(mWindow);
    if (mSurface == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_GetWindowSurface failed: %s", SDL_GetError());
        SDL_DestroyWindow(mWindow);
        SDL_Quit();
        success = false;
        return success;
    }

    return success;
}

//Double buffered, swaps the buffer here
void Display::SwapBuffers(Uint32* pixels)
{
    if (SDL_MUSTLOCK(mSurface)) 
    {
        SDL_LockSurface(mSurface);
    }

    memcpy(mSurface->pixels, pixels, SCREENWIDTH * SCREENHEIGHT * 4);

    if (SDL_MUSTLOCK(mSurface)) 
    {
        SDL_UnlockSurface(mSurface);
    }

    //Apply surface changes to window
    SDL_UpdateWindowSurface(mWindow);
}

bool Display::ShutDown()
{
    bool success = true;

    // Destroy the window and quit SDL2
    SDL_DestroyWindow(mWindow);
    mWindow = nullptr;
    SDL_Quit();

    if (mWindow != nullptr)
    {
        success = false;

        return success;
    }

    return success;

}

================
File: src/drawing.cpp
================
#include "drawing.h"
#include <algorithm>

Drawing::Drawing(){}

Drawing::~Drawing(){}

// Textures are in RGB24 format
const SDL_PixelFormat* const Drawing::pixelFormat = SDL_AllocFormat(SDL_PIXELFORMAT_RGB24);

//Precalculated gamma table, I got it from Angelo Ortiz's software renderer
const int gammaTable[256] = { 0, 21, 28, 34, 39, 43, 46,
        50, 53, 56, 59, 61, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
        85, 87, 89, 90, 92, 93, 95, 96, 98, 99, 101, 102, 103, 105, 106,
        107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119, 120, 122,
        123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,
        136, 137, 138, 139, 140, 141, 142, 143, 144, 144, 145, 146, 147,
        148, 149, 150, 151, 151, 152, 153, 154, 155, 156, 156, 157, 158,
        159, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 167, 168,
        169, 170, 170, 171, 172, 173, 173, 174, 175, 175, 176, 177, 178,
        178, 179, 180, 180, 181, 182, 182, 183, 184, 184, 185, 186, 186,
        187, 188, 188, 189, 190, 190, 191, 192, 192, 193, 194, 194, 195,
        195, 196, 197, 197, 198, 199, 199, 200, 200, 201, 202, 202, 203,
        203, 204, 205, 205, 206, 206, 207, 207, 208, 209, 209, 210, 210,
        211, 212, 212, 213, 213, 214, 214, 215, 215, 216, 217, 217, 218,
        218, 219, 219, 220, 220, 221, 221, 222, 223, 223, 224, 224, 225,
        225, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231,
        232, 232, 233, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238,
        238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244,
        245, 245, 246, 246, 247, 247, 248, 248, 249, 249, 249, 250, 250,
        251, 251, 252, 252, 253, 253, 254, 254, 255, 255 };

//Calculate the barycentric coordinates of a point in a triangle.
//Derived from Christer Ericson's "Real-Time Collision Detection"
glm::vec3 barycentric(glm::vec3 p, glm::vec3 a, glm::vec3 b, glm::vec3 c) 
{
    glm::vec3 v0 = b - a;
    glm::vec3 v1 = c - a;
    glm::vec3 v2 = p - a;
    float d00 = glm::dot(v0, v0);
    float d01 = glm::dot(v0, v1);
    float d11 = glm::dot(v1, v1);
    float d20 = glm::dot(v2, v0);
    float d21 = glm::dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0f - v - w;
    return glm::vec3(u, v, w);
}

void Drawing::PutPixel(Uint32* pixels, int x, int y, Uint32 colour)
{
    pixels[y * Display::SCREENWIDTH + x] = colour;
}

void Drawing::DrawTriangle(Uint32* pixels, glm::vec4* vertices, PBRShader& shader, float* zBuffer)
{
    glm::vec3 finalColor;

    glm::vec3 ndcVert[3];

    glm::vec3 hW = glm::vec3(1 / vertices[0].w, 1 / vertices[1].w, 1 / vertices[2].w);

    //Perspective divide
    for (int i = 0; i < 3; i++)
    {
        ndcVert[i] = vertices[i] / vertices[i].w;
    }

    Drawing::ViewPortTransform(ndcVert);

    // Calculate the bounding box of the triangle
    int minX = std::min({ ndcVert[0].x, ndcVert[1].x, ndcVert[2].x });
    int maxX = std::max({ ndcVert[0].x, ndcVert[1].x, ndcVert[2].x });
    int minY = std::min({ ndcVert[0].y, ndcVert[1].y, ndcVert[2].y });
    int maxY = std::max({ ndcVert[0].y, ndcVert[1].y, ndcVert[2].y });

    // Clamp the bounding box to the screen dimensions
    minX = std::max(minX, 0);
    maxX = std::min(maxX, Display::SCREENWIDTH - 1);
    minY = std::max(minY, 0);
    maxY = std::min(maxY, Display::SCREENHEIGHT - 1);

    glm::vec3 zVals = { ndcVert[0].z, ndcVert[1].z, ndcVert[2].z };


    for (int y = minY; y <= maxY; y++)
    {
        for (int x = minX; x <= maxX; x++)
        {
            //Add 0.5 to get pixel center
            glm::vec3 P = { x + 0.5f, y + 0.5f, 0.0f };

            glm::vec3 bc_screen = barycentric(P, ndcVert[0], ndcVert[1], ndcVert[2]);

            if (bc_screen.x >= 0.0f && bc_screen.y >= 0.0f && bc_screen.z >= 0.0f)
            {

                //Interpolate z values for z-buffer
                for (int i = 0; i < 3; i++)
				{
					P.z += ndcVert[i][2] * bc_screen[i];
				}

                if (zBuffer[int(P.x + P.y * Display::SCREENWIDTH)] > P.z)
                {  
                    zBuffer[int(P.x + P.y * Display::SCREENWIDTH)] = P.z;

                    //Calculate perspective correct barycentric coordinates
                    glm::vec3 f = bc_screen * hW;
                    float areaPers = 1.0f / (f.x + f.y + f.z);
                    glm::vec3 bc_persp = f * areaPers;

                    finalColor = shader.fragment(bc_persp);

                    PutPixel(pixels, P.x, P.y, SDL_MapRGB(pixelFormat, 
                                                gammaAdjust(finalColor.r), 
                                                gammaAdjust(finalColor.g), 
                                                gammaAdjust(finalColor.b)));
                }
            }
        }
    }
}

//Transforms the ndc vertices to screen coordinates
void Drawing::ViewPortTransform(glm::vec3* vertices)
{
    for (int i = 0; i < 3; i++)
    {
        // Transform to screen coordinates
        vertices[i].x = ((vertices[i].x + 1) * Display::SCREENWIDTH * 0.5f);
        vertices[i].y = ((vertices[i].y + 1) * Display::SCREENHEIGHT * 0.5f);
    }
}

//Adjusts gamma to 2.2, derived from Angelo Ortiz's software renderer
int Drawing::gammaAdjust(float n) 
{
    int val = static_cast<int>(glm::clamp(n * 255.0f, 0.0f, 255.0f) + 0.5f);

    if (val < 0)
    {
        val = 0;
    }

    return gammaTable[val];
}

================
File: src/engine.cpp
================
#include "engine.h"
#include <iostream>

//Dummy constructor and destructor
//The start up needs to be done in a specific order
Engine::Engine() {}
Engine::~Engine() {}

bool Engine::StartUp()
{
	bool success = true;

	if (!displayInstance.StartUp())
	{
		success = false;
		return success;
	}

    if (!renderInstance.StartUp(displayInstance.SCREENWIDTH, displayInstance.SCREENHEIGHT))
    {
        success = false;
        return success;
    }

    if (!inputInstance.StartUp(&renderInstance))
    {
        success = false;
        return success;
    }

    return success;
}

void Engine::Run()
{
    Uint32 startTime = SDL_GetTicks();
    Uint32 totalFrameTime = 0;
    Uint32 frameTime = 0;
    int frameCounter = 0;

    // Run the game loop
    bool quit = false;
    while (!quit) 
    {
        inputInstance.ProcessEvents(quit, frameTime);
        // Draw graphics
        renderInstance.render();
        // Present the back buffer to the screen
        displayInstance.SwapBuffers(renderInstance.getPixelBuffer());


        //Time keeping functions
        Uint32 endTime = SDL_GetTicks();
        frameTime = endTime - startTime;
        startTime = endTime;
        totalFrameTime += frameTime;
        frameCounter++;

        if (totalFrameTime >= 1000)
        {
            float averageFrameRate = frameCounter / (totalFrameTime / 1000.0f);
            std::cout << "Average Frame Rate: " << averageFrameRate << "    m/s Time: " << (int)frameTime << "\n\n";
            totalFrameTime = 0;
            frameCounter = 0;
        }
    }
}

//Shut down the instances in reverse to avoid dangling pointers
void Engine::ShutDown()
{
    inputInstance.ShutDown();

    renderInstance.ShutDown();

	displayInstance.ShutDown();
}

================
File: src/input.cpp
================
#include "input.h"
#include "engine.h"
#include <iostream>


Input::Input(){}

Input::~Input(){}

bool Input::StartUp(Renderer* renderer)
{
    mRenderer = renderer;

    std::string defaultFilepath = "./assets/teapot/teapot.txt";
    mRenderer->loadScene(defaultFilepath);

    return true;
}

void Input::ProcessEvents(bool& quit, Uint32 totalFrameTime)
{
    const Uint8* keyboardState = SDL_GetKeyboardState(NULL);

    totalFrameTime;
    SDL_Event event;
    bool rightMouseButtonDown = false;
    while (SDL_PollEvent(&event))
    {
        if (event.type == SDL_QUIT)
        {
            quit = true;
        }
        else if (event.type == SDL_MOUSEBUTTONDOWN)
        {
            if (event.button.button == SDL_BUTTON_RIGHT)
            {
                
                std::cout << "Right button\n";
                SDL_SetRelativeMouseMode(SDL_TRUE);
            }
        }
        else if (event.type == SDL_MOUSEBUTTONUP)
        {
            if (event.button.button == SDL_BUTTON_RIGHT)
            {
                std::cout << "Mouse released\n";
                SDL_SetRelativeMouseMode(SDL_FALSE);
            }
        }
        else if (event.type == SDL_KEYDOWN)
        {
            if (event.key.keysym.sym == SDLK_ESCAPE)
            {
                quit = true;
            }
            if (event.key.keysym.sym == SDLK_1)
            {
                std::string filepath = "./assets/teapot/teapot.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_2)
            {
                std::string filepath = "./assets/firehydrant/firehydrant.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_3)
            {
                std::string filepath = "./assets/statue/statue.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_4)
            {
                std::string filepath = "./assets/cerberus/cerberus.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_5)
            {
                std::string filepath = "./assets/heating/heating.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_6)
            {
                std::string filepath = "./assets/chest/chest.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_7)
            {
                std::string filepath = "./assets/lantern/lantern.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
            if (event.key.keysym.sym == SDLK_8)
            {
                std::string filepath = "./assets/material_test/material_test.txt";
                mRenderer->clearScene();
                mRenderer->loadScene(filepath);
            }
        }
    }

    // Process mouse movement outside the event loop
    if (SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_RIGHT))
    {
        int deltaX, deltaY;
        SDL_GetRelativeMouseState(&deltaX, &deltaY);
        mRenderer->getSceneCamera()->RotateCamera(deltaX * 0.05f, deltaY * 0.05f); // Adjust the scaling factors as needed
    }

    // Process keyboard input outside the event loop
    if (keyboardState[SDL_SCANCODE_W])
    {
        mRenderer->getSceneCamera()->MoveForward(0.005f * totalFrameTime);
    }
    if (keyboardState[SDL_SCANCODE_S])
    {
        mRenderer->getSceneCamera()->MoveBackward(0.005f * totalFrameTime);
    }
    if (keyboardState[SDL_SCANCODE_A])
    {
        mRenderer->getSceneCamera()->StrafeLeft(0.005f * totalFrameTime);
    }
    if (keyboardState[SDL_SCANCODE_D])
    {
        mRenderer->getSceneCamera()->StrafeRight(0.005f * totalFrameTime);
    }

    // mRenderer->getScene().UpdateLights(totalFrameTime);
}



void Input::ShutDown()
{
    mRenderer = nullptr;
}

================
File: src/main.cpp
================
#include "engine.h"
#include <iostream>

//SDL main
int main(int argc, char* argv[]) {
    
    Engine engine;

    if (engine.StartUp())
    {
        engine.Run();
    }
    else
    {
        std::cout << "Engine could not be initialised.\n";
    }

    engine.ShutDown();


    return 0;
}

================
File: src/model.cpp
================
#include "model.h"
#include <iostream>
#define TINYOBJLOADER_IMPLEMENTATION

#include "tiny_obj_loader.h"

Model::Model(){}

Model::~Model(){}

//Tinyobjloader to load the mesh data

bool Model::loadModel(const std::string& filename)
{
    std::string input = filename;

    tinyobj::ObjReaderConfig reader_config;
    tinyobj::ObjReader reader;

    if (!reader.ParseFromFile(input, reader_config))
    {
        if (!reader.Error().empty())
        {
            std::cerr << "TinyObjReader: " << reader.Error();
        }
        return false;
    }

    if (!reader.Warning().empty())
    {
        std::cout << "TinyObjReader: " << reader.Warning();
    }

    auto& attrib = reader.GetAttrib();
    auto& shapes = reader.GetShapes();

    // Store unique vertices, UVs, and normals
    for (size_t i = 0; i < attrib.vertices.size(); i += 3)
    {
        mVertices.push_back(glm::vec3(attrib.vertices[i], attrib.vertices[i + 1], attrib.vertices[i + 2]));
    }

    for (size_t i = 0; i < attrib.texcoords.size(); i += 2)
    {
        mUVs.push_back(glm::vec3(attrib.texcoords[i], attrib.texcoords[i + 1], 0.0f));
    }

    for (size_t i = 0; i < attrib.normals.size(); i += 3)
    {
        mNormals.push_back(glm::vec3(attrib.normals[i], attrib.normals[i + 1], attrib.normals[i + 2]));
    }

    for (size_t s = 0; s < shapes.size(); s++)
    {
        size_t index_offset = 0;

        for (size_t f = 0; f < shapes[s].mesh.num_face_vertices.size(); f++)
        {
            int fv = shapes[s].mesh.num_face_vertices[f];

            if (fv != 3)
            {
                continue;
            }

            glm::ivec3 faceVertexIndices;
            glm::ivec3 faceTextureIndices;
            glm::ivec3 faceNormalIndices;

            for (size_t v = 0; v < 3; v++)
            {
                tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];

                faceVertexIndices[v] = idx.vertex_index;
                faceTextureIndices[v] = idx.texcoord_index;
                faceNormalIndices[v] = idx.normal_index;
            }

            mVertexIndices.push_back(faceVertexIndices);
            mTextureIndices.push_back(faceTextureIndices);
            mNormalIndices.push_back(faceNormalIndices);

            index_offset += fv;
            mNumFaces++;
        }
    }

    //Calculate face normals for back face culling
    for (int i = 0; i < mNumFaces; ++i) 
    {
        glm::ivec3 faceVertexIndices = mVertexIndices[i];

        int index0 = faceVertexIndices.x;
        int index1 = faceVertexIndices.y;
        int index2 = faceVertexIndices.z;

        glm::vec3 v0 = mVertices[index0];
        glm::vec3 v1 = mVertices[index1];
        glm::vec3 v2 = mVertices[index2];

        glm::vec3 edge1 = v1 - v0;
        glm::vec3 edge2 = v2 - v0;

        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));
        mFaceNormals.push_back(faceNormal);
    }

    CalculateTangent();

    std::cout << "V: " << mVertices.size() << " F: " << mNumFaces << " UV: " << mUVs.size() << " FN: " << mFaceNormals.size() << "\n";

    return true;
}

//Calculates the tangent space of the model
//Derived from Angelo Ortiz's software renderer
//I tried several other ways, but his way works the best
void Model::CalculateTangent()
{
    std::vector<std::vector<glm::vec3>> tempTangents(mVertices.size());
    std::vector<std::vector<glm::vec3>> tempBiTangents(mVertices.size());
    glm::vec3 tangent, biTangent;

    for (int i = 0; i < mNumFaces; ++i) 
    {
        glm::ivec3 vIndices = mVertexIndices[i];
        glm::ivec3 tIndices = mTextureIndices[i];

        glm::vec3 v0 = mVertices[vIndices[0]];
        glm::vec3 v1 = mVertices[vIndices[1]];
        glm::vec3 v2 = mVertices[vIndices[2]];

        glm::vec3 edge1 = v1 - v0;
        glm::vec3 edge2 = v2 - v0;

        glm::vec3 deltaUV1 = mUVs[tIndices[1]] - mUVs[tIndices[0]];
        glm::vec3 deltaUV2 = mUVs[tIndices[2]] - mUVs[tIndices[0]];

        float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

        tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
        tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
        tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);
        tangent = glm::normalize(tangent);

        biTangent.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);
        biTangent.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);
        biTangent.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);
        biTangent = glm::normalize(biTangent);

        tempTangents[vIndices[0]].push_back(tangent);
        tempTangents[vIndices[1]].push_back(tangent);
        tempTangents[vIndices[2]].push_back(tangent);

        tempBiTangents[vIndices[0]].push_back(biTangent);
        tempBiTangents[vIndices[1]].push_back(biTangent);
        tempBiTangents[vIndices[2]].push_back(biTangent);

    }

    for (int j = 0; j < mVertices.size(); ++j) 
    {
        int count1 = 0, count2 = 0;

        glm::vec3 temp1{ 0 };
        while (!tempTangents[j].empty()) 
        {
            ++count1;
            temp1 += tempTangents[j].back();
            if (temp1.x == 0 && temp1.y == 0 && temp1.z == 0) 
            {
                temp1 = tempTangents[j].back();
            }
            tempTangents[j].pop_back();
        }

        temp1 = temp1 * (1.0f / count1);
        mTangents.push_back(temp1);

        glm::vec3 temp2{ 0 };
        while (!tempBiTangents[j].empty()) 
        {

            ++count2;
            temp2 += tempBiTangents[j].back();
            if (temp2.x == 0 && temp2.y == 0 && temp2.z == 0) 
            {
                temp2 = tempBiTangents[j].back();
            }
            tempBiTangents[j].pop_back();
        }
        temp2 = temp2 * (1.0f / count2);
        mBiTangents.push_back(temp2);
    }
 
}

// GETTERS AND SETTERS

//Set model matrices
void Model::SetTranslate(glm::vec3 translate)
{
    mTranslate = glm::translate(glm::mat4(1.0f), translate);
}

void Model::SetRotation(glm::vec3 rotation)
{
    rotate = rotation;

    mRotation = glm::rotate(glm::mat4(1.0f), glm::radians(rotation.x), glm::vec3(1.0f, 0.0f, 0.0f));
    mRotation = glm::rotate(mRotation, glm::radians(rotation.y), glm::vec3(0.0f, 1.0f, 0.0f));
    mRotation = glm::rotate(mRotation, glm::radians(rotation.z), glm::vec3(0.0f, 0.0f, 1.0f));
}

void Model::SetScale(glm::vec3 scale)
{
    mScale = glm::scale(glm::mat4(1.0f), scale);
}

void Model::SetModelMatrix()
{
    mModelMatrix = mTranslate * mRotation * mScale;
}

glm::mat4 Model::GetModelMatrix()
{
    return mModelMatrix;
}

================
File: src/renderer.cpp
================
#include "renderer.h"
#include "drawing.h"
#include "SDL_image.h"
#include <glm/gtc/matrix_inverse.hpp>
#include "omp.h"

//Dummy constructor and destructor
Renderer::Renderer(){}
Renderer::~Renderer(){}



bool Renderer::StartUp(const int w, const int h)
{
	bool success = true;

	int imgFlags = IMG_INIT_PNG | IMG_INIT_JPG;
	if (!(IMG_Init(imgFlags) & imgFlags)) 
	{
		// Handle the error
		SDL_Log("Failed to initialize SDL_image: %s", IMG_GetError());
		success = false;
		return success;
	}

	mPixelBuffer = new Uint32[w * h];

	mZbuffer = new float[w * h];

	return success;
}

void Renderer::render()
{
	bufferClear();

	PBRShader shader;

	// TODO: implement frustum culling 

	for (auto& model : mCurrentScene.getScene())
	{
		AABB transformedBB;

		//Vertices
		std::vector<glm::vec3>* vertices = model->getVertices();
		std::vector<glm::ivec3>* vertexIndices = model->getVertexIndices();

		//Texture coordinates
		std::vector<glm::vec3>* UVs = model->getUV();
		std::vector<glm::ivec3>* textureIndices = model->getTextureIndices();

		//Normals
		std::vector<glm::vec3>* normals = model->getNormals();
		std::vector<glm::ivec3>* normalIndices = model->getNormalIndices();

		//Face normals
		std::vector<glm::vec3>* faceNormals = model->getFaceNormals();

		//Tangents
		std::vector<glm::vec3>* tangents = model->getTangent();

		shader.cameraPos = getSceneCamera()->position;
		
		//Shader textures
		shader.mAlbedo = &model->mAlbedo;
		shader.mAO = &model->mAmbientO;
		shader.mMetal = &model->mMetallic;
		shader.mRough = &model->mRoughness;
		shader.mNormal = &model->mNormal;
		shader.mHeight = &model->mHeight;

		//Shader matrices
		shader.MV = getSceneCamera()->getView() * model->GetModelMatrix();
		shader.MVP = getSceneCamera()->getPerspective() * shader.MV;
		shader.M = model->GetModelMatrix();
		shader.N = glm::transpose(glm::inverse(shader.M));

		glm::mat4 worldToObject = glm::inverse(shader.M);

		//Shader Lights
		shader.lights = mCurrentScene.getLights();

		std::vector<Lights*> lights = mCurrentScene.getLights();
		
		// OpenMP for parallelisation, each thread needs its own shader
		// backface culling causes a large amount of threads to terminate
		// so schedule dynamic threads
		#pragma omp parallel for firstprivate(shader) schedule(dynamic)
		for (int i = 0; i < model->mNumFaces; ++i)
		{
			glm::vec3 triangleVertex[3], triangleNormal[3], triangleTexture[3], triangleTangent[3];

			glm::ivec3 faceV = (*vertexIndices)[i];
			glm::ivec3 faceN = (*normalIndices)[i];
			glm::ivec3 faceT = (*textureIndices)[i];


			//Pack data into triangles
			for (int j = 0; j < 3; j++)
			{
				triangleVertex[j] = (*vertices)[faceV[j]];
				triangleNormal[j] = (*normals)[faceN[j]];
				triangleTexture[j] = (*UVs)[faceT[j]];
				triangleTangent[j] = (*tangents)[faceV[j]];
			}

			//If triangle is facing away from camera cull it
			if (BackfaceCulling((*faceNormals)[i], triangleVertex[0], worldToObject))
			{
				continue;
			}

			glm::vec4 clipTri[3];

			for (int j = 0; j < 3; j++)
			{
				clipTri[j] = shader.vertex(triangleVertex[j], triangleTexture[j], triangleTangent[j], triangleNormal[j], j);
			}

			if (clipTriangles(clipTri))
			{
				continue;
			}
			
			Drawing::DrawTriangle(mPixelBuffer, clipTri, shader, mZbuffer);
		}
	}
}

bool Renderer::clipTriangles(glm::vec4* triangle)
{
	for (int i = 0; i < 3; ++i)
	{
		if (triangle[i].x < -triangle[i].w || triangle[i].x > triangle[i].w ||
			triangle[i].y < -triangle[i].w || triangle[i].y > triangle[i].w ||
			triangle[i].z < -triangle[i].w || triangle[i].z > triangle[i].w)
		{
			return true; // Clip if any vertex is outside of the view frustum
		}
	}

	return false; // Don't clip if all vertices are inside the view frustum
}

// Clears both of the buffers
// Maybe better way to do this but i'munable to think of one
void Renderer::bufferClear()
{
	for (int i = 0; i < Display::SCREENWIDTH * Display::SCREENHEIGHT; i++)
	{
		mPixelBuffer[i] = 0;
	}

	for (int i = 0; i < Display::SCREENWIDTH * Display::SCREENHEIGHT; i++)
	{
		mZbuffer[i] = 1.0f;
	}
}

void Renderer::loadScene(std::string& filePath)
{
	mCurrentScene.loadScene(filePath);
}

void Renderer::clearScene()
{
	mCurrentScene.clearScene();
}

bool Renderer::BackfaceCulling(glm::vec3& faceNorm, glm::vec3& vert, glm::mat4& worldToObject)
{
	glm::vec3 viewDir = glm::vec3(worldToObject * glm::vec4(getSceneCamera()->position, 1.0f)) - vert;
	viewDir = glm::normalize(viewDir);

	float intensity = glm::dot(faceNorm, viewDir);

	return intensity <= 0.0f;

}

// GETTERS AND SETTERS

Uint32* Renderer::getPixelBuffer()
{
	return mPixelBuffer;
}

//Deletes the buffers
bool Renderer::ShutDown() 
{ 
	delete[] mPixelBuffer;

	delete[] mZbuffer;

	return true; 
}

================
File: src/scene.cpp
================
#include "scene.h"
#include <iostream>
#include <sstream>
#include <fstream>
#include <utility>


Scene::Scene(){}

Scene::~Scene(){}

void Scene::loadScene(std::string& sceneFile)
{
    std::ifstream scene(sceneFile);
    if (!scene.is_open())
    {
        std::cerr << "Error opening scene file: " << sceneFile << std::endl;
        return;
    }

    std::string line;
    std::unique_ptr<Model> model;

    while (std::getline(scene, line))
    {
        std::istringstream lineStream(line);
        std::string keyword;

        lineStream >> keyword;

        if (keyword == "s") 
        {
            lineStream >> name;
        }
        else if (keyword == "m") 
        {
            lineStream >> numModels;
        }
        else if (keyword == "MODEL") 
        {
            std::string path;
            lineStream >> path;

            model = std::make_unique<Model>();

            model->loadModel(path);

        }
        else if (keyword == "ALB")
        {
            std::string path;
            lineStream >> path;

            //ALB
            model->mAlbedo.LoadTexture(path);
        }
        else if (keyword == "AO")
        {
            std::string path;
            lineStream >> path;

            //AO
            model->mAmbientO.LoadTexture(path);
        }
        else if (keyword == "METAL")
        {
            std::string path;
            lineStream >> path;

            //METAL
            model->mMetallic.LoadTexture(path);
        }
        else if (keyword == "NORM")
        {
            std::string path;
            lineStream >> path;

            //NORM
            model->mNormal.LoadTexture(path);
        }
        else if (keyword == "ROUGH")
        {
            std::string path;
            lineStream >> path;

            //ROUGH
            model->mRoughness.LoadTexture(path);
        }
        else if (keyword == "HEIGHT")
        {
            std::string path;
            lineStream >> path;

            //HEIGHT
            model->mHeight.LoadTexture(path);
        }
        else if (keyword == "TRANSLATE")
        {
            glm::vec3 translation;

            lineStream >> translation.x >> translation.y >> translation.z;

            model->SetTranslate(translation);
        }
        else if (keyword == "ROTATION")
        {
            glm::vec3 rotation;

            lineStream >> rotation.x >> rotation.y >> rotation.z;   
            model->SetRotation((rotation));
            
        }
        else if (keyword == "SCALE")
        {
            glm::vec3 scale;

            lineStream >> scale.x >> scale.y >> scale.z;

            model->SetScale(scale);
        }
        else if (keyword == "END_MODEL")
        {
            if (model) 
            {
                model->SetModelMatrix();
                modelsInScene.push_back(std::move(model));
                model.reset();
            }
        }
        else if (keyword == "PLIGHT")
        {
            
            glm::vec3 position;
            glm::vec3 color;
            float intensity;

            lineStream >> position.x >> position.y >> position.z >> intensity >> color.r >> color.g >> color.b;

            mNumLights++;

            lightsInScene.push_back(std::make_unique<Lights>(position, intensity, color ));

        }
        else if (keyword == "CAMERA")
        {
            Camera camera;

            mCamera = camera;
        }
    }

    std::cout << this->numModels << " " << this->name << "\n";
}

void Scene::clearScene()
{
    // Clear the models and lights vectors
    modelsInScene.clear();
    lightsInScene.clear();

    // Reset the model and light counts
    numModels = 0;
    mNumLights = 0;
    
    //Resets the camera
    mCamera = Camera(); 
}


//GETTERS AND SETTERS

std::vector<Model*> Scene::getScene()
{
    std::vector<Model*> modelPtrs;
    for (const auto& model : modelsInScene) 
    {
        modelPtrs.push_back(model.get());
    }
    return modelPtrs;
}

std::vector<Lights*> Scene::getLights()
{
    std::vector<Lights*> lightPtrs;
    for (const auto& light : lightsInScene)
    {
        lightPtrs.push_back(light.get());
    }

    return lightPtrs;
}

void Scene::UpdateLights(int delta)
{
    for (int i = 0; i < lightsInScene.size(); i++)
    {        
        lightsInScene[i]->Update(delta);
    }
}

================
File: src/texture.cpp
================
#include "texture.h"
#include <iostream>
#include <algorithm>

Texture::Texture(){}

Texture::~Texture()
{
    SDL_FreeSurface(mTextureSurface);
}

void flipSurfaceVertically(SDL_Surface* surface)
{
    int pitch = surface->pitch;
    int height = surface->h;
    void* pixels = surface->pixels;

    int rowSize = pitch * sizeof(Uint8);
    Uint8* rowBuffer = new Uint8[rowSize];

    for (int y = 0; y < height / 2; y++)
    {
        Uint8* row1 = static_cast<Uint8*>(pixels) + y * pitch;
        Uint8* row2 = static_cast<Uint8*>(pixels) + (height - y - 1) * pitch;

        std::memcpy(rowBuffer, row1, rowSize);
        std::memcpy(row1, row2, rowSize);
        std::memcpy(row2, rowBuffer, rowSize);
    }

    delete[] rowBuffer;
}

void Texture::LoadTexture(const std::string& filename)
{
	mTextureSurface = IMG_Load(filename.c_str());
    if (!mTextureSurface)
    {
        SDL_Log("Failed to load image: %s", IMG_GetError());
        return;
    }
    std::cout << "Loaded: " << filename << "\n";

    SDL_PixelFormat* pixelFormat = mTextureSurface->format;
    std::cout << "Pixel format for " << filename << ":\n";
    std::cout << "  Bits per pixel: " << static_cast<int>(pixelFormat->BitsPerPixel) << std::endl;
    std::cout << "  Bytes per pixel: " << static_cast<int>(pixelFormat->BytesPerPixel) << std::endl;
    std::cout << "  Format code: 0x" << std::hex << pixelFormat->format << std::endl;
    std::cout << "  Format name: " << SDL_GetPixelFormatName(pixelFormat->format) << std::endl;

    width = mTextureSurface->w;
    height = mTextureSurface->h;

    flipSurfaceVertically(mTextureSurface);

    
}

void Texture::TileData() 
{
    // Create a new surface with the same pixel format but adjusted dimensions
    SDL_Surface* tiledSurface = SDL_CreateRGBSurface(0, width * tileW, height * tileH, mTextureSurface->format->BitsPerPixel, mTextureSurface->format->Rmask, mTextureSurface->format->Gmask, mTextureSurface->format->Bmask, mTextureSurface->format->Amask);
    if (!tiledSurface)
    {
        SDL_Log("Failed to create surface: %s", SDL_GetError());
        return;
    }

    // Access the pixel data
    Uint32* pixelData = static_cast<Uint32*>(mTextureSurface->pixels);
    Uint32* tiledPixelData = static_cast<Uint32*>(tiledSurface->pixels);

    int tileNumW = width / tileW;
    int tileNumH = height / tileH;

    for (int tileRow = 0; tileRow < tileNumW; ++tileRow) {
        for (int tileCol = 0; tileCol < tileNumH; ++tileCol) {
            for (int tilePixelHeight = 0; tilePixelHeight < tileH; ++tilePixelHeight) {
                int linearIndex = (tilePixelHeight * width + tileCol * tileW + tileRow * width * tileH);
                for (int tilePixelWidth = 0; tilePixelWidth < tileW; ++tilePixelWidth) {
                    int tiledIndex = ((tileRow * tileH + tilePixelHeight) * width * tileNumW + tileCol * tileW + tilePixelWidth);
                    tiledPixelData[tiledIndex] = pixelData[linearIndex++];
                }
            }
        }
    }

    // Replace the original surface with the new one
    SDL_FreeSurface(mTextureSurface);
    mTextureSurface = tiledSurface;
}


// Function from https://www.libsdl.org/release/SDL-1.2.15/docs/html/guidevideo.html
Uint32 Texture::GetPixel(int u, int v) const
{
    if (u < 0 || v < 0)
    {
        u = 0;
        v = 0;
    }

    int bpp = mTextureSurface->format->BytesPerPixel;
    Uint8* p = (Uint8*)mTextureSurface->pixels + v * mTextureSurface->pitch + u * bpp;

    switch (bpp)
    {
    case 1:
        return *p;
    case 2:
        return *(Uint16*)p;
    case 3:
        if (SDL_BYTEORDER == SDL_BIG_ENDIAN)
            return p[0] << 16 | p[1] << 8 | p[2];
        else
            return p[0] | p[1] << 8 | p[2] << 16;
    case 4:
        return *(Uint32*)p;
    default:
        return 0;
    }
}

// Nearest neighbour sampling
// Used bilinear but it caused a massive slow down
// Probably because I used getpixel four times to get the information required for bilinear interpolation

glm::vec3 Texture::SampleTexture(float u, float v) const
{
    // Wrap the UV coordinates using the modulo operator
    u = fmod(u, 1.0f);
    v = fmod(v, 1.0f);

    // If the UV coordinate is negative, add 1 to make it positive
    if (u < 0.0f) u += 1.0f;
    if (v < 0.0f) v += 1.0f;

    float x = u * mTextureSurface->w;
    float y = v * mTextureSurface->h;

    Uint32 color;

    color = GetPixel(x, y);

    // Needed to use exception for when pixel value outside of texture range
    // Maybe can be solved with proper frustum culling so it doesn't render the model at all?
    //try 
    //{
    //    
    //}
    //catch (const std::out_of_range& e) 
    //{
    //    std::cerr << "Error: " << e.what() << std::endl;
    //    color = 0;  // Default pixel color.
    //}
    //catch (const std::runtime_error& e) 
    //{
    //    std::cerr << "Error: " << e.what() << std::endl;
    //}

    Uint8 r, g, b;

    SDL_GetRGB(color, mTextureSurface->format, &r, &g, &b);

    glm::vec3 colorVec(static_cast<float>(b) / 255.0f, static_cast<float>(g) / 255.0f, static_cast<float>(r) / 255.0f);

    return colorVec;

}
